var documenterSearchIndex = {"docs":
[{"location":"steady_state/#ss_page","page":"Steady State","title":"Steady State","text":"","category":"section"},{"location":"steady_state/#LinearOptics","page":"Steady State","title":"LinearOptics","text":"","category":"section"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"The time evolution of LinearOptics follows the equation:","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"fracdvecbetadt = Gvecbeta + vecOmega","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"which has a well-defined formal solution:","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"vecbeta_s = -G^-1vecOmega","category":"page"},{"location":"steady_state/#Scalar","page":"Steady State","title":"Scalar","text":"","category":"section"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"In the Scalar case, the solution is a Vector: ","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"using CoupledDipoles\nr =[1 2 0;\n    1 0 1.0]\natoms = Atom(Cube(), Array(transpose(r)), 10)\nlaser = Laser(PlaneWave3D(), 1e-6, 1.0)\nproblem = LinearOptics(Scalar(), atoms, laser)\nβₛ = steady_state(problem) # N-array","category":"page"},{"location":"steady_state/#Vectorial","page":"Steady State","title":"Vectorial","text":"","category":"section"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"In Vectorial case, one gets a Matrix:","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"each row represents the x,y,z-components of the polarization\neach colums correspond to different atoms","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"# (...) same as Scalar case\nproblem = LinearOptics(Vectorial(), atoms, laser)\nβₛ = steady_state(problem) # 3xN-matrix","category":"page"},{"location":"steady_state/#NonLinearOptics","page":"Steady State","title":"NonLinearOptics","text":"","category":"section"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"NonLinearOptics does not have a formal solution, therefore steady_state have two approaches","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"Use NewtonRaphson methods (default)\nIf ode_solver=true, use the time_evolution function over the period tspan = (0, 250) and return the final state","category":"page"},{"location":"steady_state/#MeanField","page":"Steady State","title":"MeanField","text":"","category":"section"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"The solution is a Vector of size 2N, corresponding to [langle sigma^- rangle langle sigma^z rangle].","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"# (...) same as Scalar case\nproblem = NonLinearOptics(MeanField(), atoms, laser)\nβₛ = steady_state(problem) # default with NewtonRaphson\n\nβₛ = steady_state(problem; ode_solver=true) # bruteforce time evoltuion","category":"page"},{"location":"steady_state/#PairCorrelation","page":"Steady State","title":"PairCorrelation","text":"","category":"section"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"The solution is a Vector of size 2N + 4N^2, corresponding to [sigma^- sigma^z sigma^zsigma^- sigma^+sigma^- sigma^-sigma^- sigma^zsigma^z].","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"# (...) same as Scalar case\nproblem = NonLinearOptics(PairCorrelation(), atoms, laser)\nβₛ = steady_state(problem) # default with NewtonRaphson\n\nβₛ = steady_state(problem; ode_solver=true) # bruteforce time evoltuion","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"","category":"page"},{"location":"steady_state/#CoupledDipoles.steady_state","page":"Steady State","title":"CoupledDipoles.steady_state","text":"steady_state(problem::LinearOptics{Scalar})\n\nSolve x=-G\\Ω, with default interaction_matrix and laser_field.\n\n\n\n\n\nsteady_state(problem::LinearOptics{Vectorial})\n\nSolve x=-G\\Ω, with default interaction_matrix and laser_field. The solution x is reshaped as a 3xN matrix.\n\n\n\n\n\nsteady_state(problem::NonLinearOptics{MeanField}; tmax = 250.0, reltol = 1e-11, abstol = 1e-10, m = 90, ode_solver = false)\n\n\n\n\n\n","category":"function"},{"location":"linear_regression/linear_regression_methods/#Linear-Regression-with-Noise-Data","page":"Fitting","title":"Linear Regression with Noise Data","text":"","category":"section"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"The localization length comes from noise data, and one needs to pre process the data before extracting any analysis. In this section, we show how we use the package LinRegOutliers.jl for our application.","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"Localization length, xi, comes from the assumption that the data follows","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"y = A_0e^-xxi","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"However, the package LinRegOutliers.jl works best with linear functions, thus, we define","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"Y = ln(A_0) -xxi","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"or","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"Y = A + Bx","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"Our goal then becomes to identify xi = -1B.","category":"page"},{"location":"linear_regression/linear_regression_methods/#Exponential-with-Noise","page":"Fitting","title":"Exponential with Noise","text":"","category":"section"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"We will create some data and check for the methods avaiable on LinRegOutliers.jl that leads to best results. Our test function will be","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"y = 2234e^-x1345","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"and we add white noise at each point of the domain x","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"using Random\nRandom.seed!(1234)\n\nx = range(0, 5, length = 40)\ny = log.(2.234exp.(-x/1.345) .+ rand(length(x)) ./ 10)","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"Now, we will create a functin that returns the coeficientes of the linear fit. For that, we specify our @formula, the Dataframe with our data, and use one of the available methods on LinRegOutliers.jldocs.","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"using LinRegOutliers, DataFrames\nfunction linear_fit_robust(x, y; regression_method = lta)\n\treg = createRegressionSetting(@formula(y ~ x), DataFrame([:x => x, :y => y]))\n\tresult = regression_method(reg)\n\n\tA, B = result[\"betas\"]\n\ty_fit = A .+ (B .* x)\n\n\treturn A, B, y_fit\nend\n## test\nA, B, y_fit = linear_fit_robust(x, y)\nξ = -1/B","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"Now, we can test and visualize the fitting result","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"using CairoMakie\nscatter(x, y, axis=(xlabel=\"x\", ylabel=\"y\"))\nlines!(x, y_fit, color = Cycled(2), linewidth = 5, label=\"ξ = $( round(ξ, digits=3))\")\naxislegend()\ncurrent_figure()","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"(Image: )","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"","category":"page"},{"location":"linear_regression/linear_regression_methods/#Methods-Comparison","page":"Fitting","title":"Methods Comparison","text":"","category":"section"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"The exact metho depends on the level of noise on the data. On this specific example, the best regression method was the asm2000.","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"begin\n    fig = Figure()\n    ax = Axis(fig[1, 1], xlabel = \"x\", ylabel=\"y\")\n    scatter!(ax, x, y)\n\tmethods_list = [hs93, ks89, smr98, lms, lts, bch, py95, satman2013, satman2015,\n\t\tasm2000, lad, lta, galts, imon2005, ccf, cm97, quantileregression]\n    comparisons = []\n\tfor method in methods_list\n\t\ta, b, y_fit = linear_fit_robust(x, y; regression_method = method)\n        lines!(ax, x, y_fit, linewidth = 1, label = \"$(method)\")\n\n        comparison =  (-1/b)/1.345\n        push!(comparisons, comparison)\n\tend\n    value, idx  = findmin(comparisons)\n    println(\"$(methods_list[idx]) had the best fitting, with ξ = $(value*1.345)\")\n\n    Legend(fig[1, 2], ax)\n\tcurrent_figure()\nend","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"(Image: )","category":"page"},{"location":"problems/problems/#Problems","page":"Problem","title":"Problems","text":"","category":"section"},{"location":"problems/problems/","page":"Problem","title":"Problem","text":"Your simulation will only work if you use the right problem data type, provided by the constructors LinearOptics or NonLinearOptics.","category":"page"},{"location":"problems/problems/","page":"Problem","title":"Problem","text":"For the LinearOptics you have the Scalar and Vectorial models, whereas the NonLinearOptics have MeanField and PairCorrelation. All of them deal with the 3 dimensions - different dimensions have different equations which are waiting for someone (not the author) to write them in the code engines.","category":"page"},{"location":"problems/problems/","page":"Problem","title":"Problem","text":"Here all the possible configurations.","category":"page"},{"location":"problems/problems/","page":"Problem","title":"Problem","text":"# settings\nN, kR = 15, 32.4\nw₀, s, Δ = 4π, 1e-5, 0.3   \natoms = Atom(CoupledDipoles.Sphere(gaussian=true), N, kL; r_min=0.0)\nlaser = Laser(Gaussian3D(w₀), s, Δ)\n\n# LinearOptics options\nprob_scalar = LinearOptics(Scalar(), atoms, laser)\nprob_vectorial = LinearOptics(Vectorial(), atoms, laser)\n\n# NonLinearOptics options\nprob_meanfield = NonLinearOptics(MeanField(), atoms, laser)\nprob_pair = NonLinearOptics(PairCorrelation(), atoms, laser)\n\n\n# (do something with your problem)\n# (...)","category":"page"},{"location":"problems/problems/","page":"Problem","title":"Problem","text":"","category":"page"},{"location":"problems/problems/#CoupledDipoles.LinearOptics","page":"Problem","title":"CoupledDipoles.LinearOptics","text":"LinearOptics(physic::Scalar, atoms, laser)\n\n\n\n\n\nLinearOptics(physic::Vectorial, atoms, laser)\n\n\n\n\n\n","category":"type"},{"location":"problems/problems/#CoupledDipoles.NonLinearOptics","page":"Problem","title":"CoupledDipoles.NonLinearOptics","text":"NonLinearOptics(physic::MeanField, atoms, laser)\n\n\n\n\n\nNonLinearOptics(physic::PairCorrelation, atoms, laser)\n\n\n\n\n\n","category":"type"},{"location":"scattering/scattering/#Scattering","page":"Scatttering","title":"Scattering","text":"","category":"section"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"The electric field measured at sensor positioned at mathbfR = Rhatn results from the sum of all  dipoles located at mathbfr_j and their respective states beta_j. The exact formula depends on the model and regime. By default, all scattering function are configured on :near_field regime. ","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"Note: Only the Vectorial Model did not have sufficient tests to be considered reliable on the :far_field (but is considered correct with :near_field)","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"","category":"page"},{"location":"scattering/scattering/#Computing-Electric-Field","page":"Scatttering","title":"Computing Electric Field","text":"","category":"section"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"To calculate electric field, use the provided functions scattered_electric_field and/or laser_and_scattered_electric_field.","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"Important Note: We have a precise definition for the distance 1/r in the far-field region. While you might normalize intensity values later, making this constant less important, we still use it in our calculations. The formula for determining the far-field distance is: how_far_is_farField(atoms) = 50*size(atoms)^2 - see the Phd Thesis for the reasoning.","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"Avoid creating your own calculations for scattered fields based on formulas from articles. We use consistent mathematical constants across different simulation regimes and models. The specific formulas we employ are as follows:","category":"page"},{"location":"scattering/scattering/#Scalar","page":"Scatttering","title":"Scalar","text":"","category":"section"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :near_field","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"E_sc(mathbfR t) = +ifracGamma2sum_j frace^ ik_0mathbfR - mathbfr_j k_0mathbfR - mathbfr_jbeta_j(t)","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :far_field","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"E_sc(mathbfR t) approx +ifracGamma2 frace^ ik_0R k_0Rsum_j exp( -ik_0hatn cdot mathbfr_j )beta_j(t)","category":"page"},{"location":"scattering/scattering/#Vectorial","page":"Scatttering","title":"Vectorial","text":"","category":"section"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :near_field","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"E_vec(mathbfR t) = -Gammasum_jsum_etaG_mueta(mathbfR-mathbfr_j)beta_j^eta(t)","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :far_field","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"E^mu_vec(mathbfRt) approx +ifrac3Gamma4 frace^ik_0Rk_0Rsum_jsum_eta(delta_mu eta - hatn_muhatn_eta^*)exp(-ik_0hatmathbfncdotmathbfr_j)beta_j^eta(t)","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"This specific equation has not been VALIDATED. If you have experience with this equation, please consider contributing to the package with benchamrks.","category":"page"},{"location":"scattering/scattering/#MeanField-and-Pair-Correlation","page":"Scatttering","title":"MeanField and Pair Correlation","text":"","category":"section"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"The formulas for electric field in MeanField and PairCorrelation are identifical to those in Scalar model","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :near_field|:far_field","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"mathbfE_mfpc = mathbfE_sc","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"","category":"page"},{"location":"scattering/scattering/#Computing-Intensity","page":"Scatttering","title":"Computing Intensity","text":"","category":"section"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"To calculate electric field intensity, use the provided functions scattered_intensity and/or laser_and_scattered_intensity.","category":"page"},{"location":"scattering/scattering/#Scalar-2","page":"Scatttering","title":"Scalar","text":"","category":"section"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :near_field|:far_field","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"I_sc(vecRt) = mathbfE_sc^2","category":"page"},{"location":"scattering/scattering/#Vectorial-2","page":"Scatttering","title":"Vectorial","text":"","category":"section"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :near_field|:far_field","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"I_vec(hatnt) = mathbfE_vec^2 = sum_muE^mu_vec^2","category":"page"},{"location":"scattering/scattering/#Mean-Field","page":"Scatttering","title":"Mean Field","text":"","category":"section"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :near_field","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"I_mf(mathbfRt) = I_sc(mathbfR t)\n+fracGamma^2(2k_0)^2 left   sum_j frac- beta_j^2    + frac1+langle sigma_j^z rangle 2R-r_j^2 right ","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :far_field","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"I_mf(mathbfRt) = I_sc(mathbfR t) + fracGamma^2(2k_0R)^2sum_j=1^N left ( -beta_j^2 + frac1 + langle sigma_j^z rangle 2right )","category":"page"},{"location":"scattering/scattering/#PairCorrelation","page":"Scatttering","title":"PairCorrelation","text":"","category":"section"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :near_field","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"I_textPairCorrelation = fracGamma^24 k_0^2 left  sum_j=1^N sum_m=1 m neq j^N left( fraclangle sigma_j^+ sigma_m^- rangle e^i mathbfk_0 cdot (mathbfr_j - mathbfr_m)mathbfr_j - mathbfR mathbfr_m - mathbfR right) + sum_j=1^N left( frac1 + langle sigma_j^z rangle 2 mathbfr_j - mathbfR^2 right)right ","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :far_field","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"I_textPairCorrelation = fracGamma^24 k_0^2 r^2 left  sum_j=1^N sum_m=1 m neq j^N   langle sigma_j^+ sigma_m^- rangle e^i hatn cdot (mathbfr_j - mathbfr_m)  + sum_j=1^N  frac1 + langle sigma_j^z rangle2  right ","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"Note that in NonLinearOptics, you can choose if you want or not the intensity computed with the Inelastic part of the scattering with inelasticPart=false.","category":"page"},{"location":"scattering/scattering/#:near_field-vs-:far_field","page":"Scatttering","title":":near_field vs :far_field","text":"","category":"section"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"Let's measure the scattered intensity over an sphere around the atomic cloud - the figure below IS NOT the cloud.","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"Create your problem, obtain the atomic states, and then, call scattered_intensity","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"using CoupledDipoles, Random\n\n# --- setup problem ---\nN, ρ = 3000, 25/(2π)^3\nRandom.seed!(100)\ncloud = Atom(CoupledDipoles.Cube(), cube_inputs(N, ρ)...)\n\nw₀, s, Δ = cloud.sizes/2, 1e-5, 0.30769230769\nlaser = Laser(Gaussian3D(w₀), s, Δ)\n\nproblem = LinearOptics(Scalar(), cloud, laser)\nβₙ = steady_state(problem)\n\n# --- creating sensors ---\nθ = LinRange(0, π, 100)\nϕ = LinRange(0, 2π, 150)\n\nR = 200 * size(cloud)\nx = R .* [sin(θ) * sin(ϕ) for θ in θ, ϕ in ϕ]\ny = R .* [sin(θ) * cos(ϕ) for θ in θ, ϕ in ϕ]\nz = R .* [cos(θ) for θ in θ, ϕ in ϕ]\ntotalNumberPoints = length(θ) * length(ϕ)\nsensors = Array([reshape(x, totalNumberPoints) reshape(y, totalNumberPoints) reshape(z, totalNumberPoints)]')\n\n# getting light intensities\nintensities_nf = scattered_intensity(problem, βₙ, sensors; regime = :near_field)\nintensities_ff = scattered_intensity(problem, βₙ, sensors; regime = :far_field)","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"(Image: Comparison between regimes)","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"The source code for the figure is:","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"begin\n\tusing CairoMakie, ColorSchemes, GeometryBasics, FileIO\n\tusing Makie: get_dim, surface_normals\n\n\tfunction getMesh(x, y, z)\n\t\tpositions = vec(\n\t\t\tmap(CartesianIndices(z)) do i\n\t\t\t\tGeometryBasics.Point{3, Float64}(\n\t\t\t\t\tget_dim(x, i, 1, size(z)),\n\t\t\t\t\tget_dim(y, i, 2, size(z)),\n\t\t\t\t\tz[i],\n\t\t\t\t)\n\t\t\tend,\n\t\t)\n\t\tfaces = decompose(GLTriangleFace, Rect2D(0.0f0, 0.0f0, 1.0f0, 1.0f0), size(z))\n\t\tnormals = surface_normals(x, y, z)\n\t\tvertices = GeometryBasics.meta(positions; normals = normals)\n\t\tmeshObj = GeometryBasics.Mesh(vertices, faces)\n\t\tmeshObj\n\tend\nend\n\n\nbegin\n    cmap = cgrad(colorschemes[:vik10], 15, categorical = true)\n\tfig = Figure(size = (900, 450))\n\n\tsubgl_left = GridLayout()\n\tsubgl_left[1, 1] = [Axis3(fig, aspect = :data, title=\":near_field\",\n\t\txlabel=\"x\", ylabel=\"y\", zlabel=\"z\" ) for i in 1:1]\n\n\tsubgl_right = GridLayout()\n\tsubgl_right[1, 1] = [Axis3(fig,aspect = :data, title=\":far_field\",\n\t\txlabel=\"x\", ylabel=\"y\", zlabel=\"z\") for i in 1:1]\n\n\tfig.layout[1, 1] = subgl_left\n\tfig.layout[1, 2] = subgl_right\n\n\n\tpltobj_nf = mesh!(subgl_left[1,1],\n\t\tgetMesh(x, y, z),\n\t\tcolor = log10.(intensities_nf),\n\t\tcolormap = cmap,\t\t\n\t)\n\tcbar1 = Colorbar(fig, pltobj_nf, label = L\"\\text{log}_{10}(\\text{Intensity})\",\n\t\t\tvertical = false, flipaxis = false, labelsize=20, width = Relative(3 / 4))\n\tcbar1.ticks = ([-17, -13, -9], [\"-17\",\"-13\", \"-9\"])\n\tsubgl_left[2,1] = cbar1\n\n\n\n\tpltobj_ff = mesh!(subgl_right[1,1],\n\t\tgetMesh(x, y, z),\n        color = log10.(intensities_ff),\n\t\tcolormap = cmap,\t\t\n\t)\n\tcbar2 = Colorbar(fig, pltobj_ff, label = L\"\\text{log}_{10}(\\text{Intensity})\",\n\t\t\tvertical = false, flipaxis = false, labelsize=20, width = Relative(3 / 4))\n\tcbar2.ticks = ([-18, -14.5, -11.0], [\"-18\",\"-14.5\", \"-11\"])\n\tsubgl_right[2,1] = cbar2\n\n\tfig\nend\n\n\nusing FileIO\nFileIO.save(\"intensity_near_far_fields.png\", fig)","category":"page"},{"location":"scattering/scattering/#Average-Intensity","page":"Scatttering","title":"Average Intensity","text":"","category":"section"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"If you need the azimuthal average intensity, that is","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"I(theta) = int_0^2piE(theta phi)^2 dphi","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"use the function get_intensity_over_an_angle which is optmized to for this problem. ","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"Because the average integral have an exact solution, we have its implementation available, but is not recommeded to use it, since it has O(N^2) in time and memory complexity - and we already verified that our default precision was reliable. In case you need more precision, decrease the tolerance of the integration with the parameter tol. ","category":"page"},{"location":"scattering/scattering/","page":"Scatttering","title":"Scatttering","text":"","category":"page"},{"location":"scattering/scattering/#CoupledDipoles.scattered_electric_field","page":"Scatttering","title":"CoupledDipoles.scattered_electric_field","text":"scattered_electric_field(problem, atomic_states, sensors; regime=:near_field, use_sequencial=false)\n\nReturns a Matrix{ComplexF64} with value of the Eletric Laser + Electric Scattered from atoms\n\nproblem: LinearOptics or NonLinearOptics\natomic_states: A vector for Scalar, MeanField and PairCorrelation. A matrix Vectorial Model\nsensors: matrix with measurement points\nuse_sequencial turn on/off the internal parallelism\n\nNote:\n\nScalar (and other models) problem returns a Matrix and NOT a Vector, to maintain consistency   with Vectorial problem that necessary returns a Matrix,   where each row has the [Ex, Ey, Ez] components of the field.\nAlso, even for single sensor, returns a Matrix of one element.\n\nExample\n\nusing CoupledDipoles, Random\nRandom.seed!(111)\nN = 5\nkR, kh = 1.0, 1.0\natoms = Atom(Cylinder(), N, kR, kh)\n\ns, Δ = 1e-5, 1.0\nlaser = Laser(PlaneWave3D(), s, Δ; polarization=[1,0,0])\n\nproblem_scalar = LinearOptics(Scalar(), atoms, laser)\nproblem_vectorial = LinearOptics(Vectorial(), atoms, laser)\n\natomic_states_scalar = steady_state(problem_scalar)\natomic_states_vectorial = steady_state(problem_vectorial)\n\n## 1 sensor\nRandom.seed!(222)\nnSensors = 1\nsensor = Matrix(rand(3, nSensors)) # '3' == sensor lives in a 3D space\nscattered_electric_field(problem_scalar, atomic_states_scalar, sensor)\nscattered_electric_field(problem_vectorial, atomic_states_vectorial, sensor)\n\n\n## 10 sensors\nRandom.seed!(333)\nnSensors = 10\nsensor = rand(3, nSensors) # '3' == sensor lives in a 3D space\nscattered_electric_field(problem_scalar, atomic_states_scalar, sensor)\nscattered_electric_field(problem_vectorial, atomic_states_vectorial, sensor)\n\n\n\n\n\n","category":"function"},{"location":"scattering/scattering/#CoupledDipoles.laser_and_scattered_intensity","page":"Scatttering","title":"CoupledDipoles.laser_and_scattered_intensity","text":"laser_and_scattered_intensity(problem, atomic_states, sensor_positions; regime=:near_field)\n\nReturns a Vector{Float64} with value of the |Electric Laser + Electric Scattered|^2 from atoms\n\nproblem: LinearOptics or NonLinearOptics\natomic_states: β for Scalar/Vectorial Model, or [β,z] for Mean Field Model\nsensors: matrix with measurement points\n\n\n\n\n\n","category":"function"},{"location":"scattering/scattering/#CoupledDipoles.scattered_intensity","page":"Scatttering","title":"CoupledDipoles.scattered_intensity","text":"scattered_intensity(problem, atomic_states, sensor_positions; regime=:near_field, use_sequencial=false)\n\nReturns a Vector{Float64} with value of the |Electric Scattered|^2 from atoms\n\nproblem: LinearOptics or NonLinearOptics\natomic_states: β for Scalar/Vectorial Model, or [β,z] for Mean Field Model\nsensor_positions: matrix with measurement points\nuse_sequencial turn on/off the internal parallelism\n\nExample\n\nusing CoupledDipoles, Random\nRandom.seed!(111)\nN = 5\nkR, kh = 1.0, 1.0\natoms = Atom(Cylinder(), N, kR, kh)\n\ns, Δ = 1e-5, 1.0\nlaser = Laser(PlaneWave3D(), s, Δ; polarization=[1,0,0])\n\nproblem_scalar = LinearOptics(Scalar(), atoms, laser)\nproblem_vectorial = LinearOptics(Vectorial(), atoms, laser)\n\natomic_states_scalar = steady_state(problem_scalar)\natomic_states_vectorial = steady_state(problem_vectorial)\n\n## 1 sensor\nRandom.seed!(222)\nnSensors = 1\nsensor = Matrix(rand(3, nSensors)) # '3' == sensor in position in 3D space\nscattered_intensity(problem_scalar, atomic_states_scalar, sensor)\nscattered_intensity(problem_vectorial, atomic_states_vectorial, sensor)\n\n\n## 10 sensors\nRandom.seed!(333)\nnSensors = 10\nsensor = rand(3, nSensors) # '3' == sensor in position in 3D space\nscattered_intensity(problem_scalar, atomic_states_scalar, sensor)\nscattered_intensity(problem_vectorial, atomic_states_vectorial, sensor)\n\n\n\n\n\nscattered_intensity(problem::NonLinearOptics{T}, atomic_states, sensors; regime=:near_field, inelasticPart=true, use_sequencial=false)\n\nIf you are working in NonLinearOptics and your intensity values become negative, probably the issue lies on the values of the inelastic component that become non-physical,  and is handy to have a function to swtich on-off this particular variable to investigate the problem.\n\nFor special case of NonLinearOptics, you have the option to neglect the inelastic component with inelasticPart=false. \n\n\n\n\n\n","category":"function"},{"location":"scattering/scattering/#CoupledDipoles.get_intensity_over_an_angle","page":"Scatttering","title":"CoupledDipoles.get_intensity_over_an_angle","text":"get_intensity_over_an_angle(problem::LinearOptics{Scalar}, atoms_states::Vector{ComplexF64}, θ::Number; tol=exp10(-7.4), exact_solution=false)\n\nUsed for the single angle and single single state (most probably user case).\n\nExample:\n\nusing CoupledDipoles, Random\nRandom.seed!(111)\nN = 5\nkR, kh = 1.0, 1.0\natoms = Atom(Cylinder(), N, kR, kh)\n\ns, Δ = 1e-5, 1.0\nlaser = Laser(PlaneWave3D(), s, Δ; polarization=[1,0,0])\n\nproblem_scalar = LinearOptics(Scalar(), atoms, laser)\natomic_states_scalar = steady_state(problem_scalar)\n\nθ = deg2rad(48)\nget_intensity_over_an_angle(problem_scalar, atomic_states_scalar, θ)\n\n\n\n\n\nget_intensity_over_an_angle(problem::LinearOptics{Scalar}, atoms_states::Vector{Vector{ComplexF64}}, θ::Number; tol=exp10(-7.4), exact_solution=false)\n\nUsed for the single angle and different states (for example, the output of time_evolution).\n\nExample:\n\nusing CoupledDipoles, Random\nRandom.seed!(111)\nN = 5\nkR, kh = 1.0, 1.0\natoms = Atom(Cylinder(), N, kR, kh)\n\ns, Δ = 1e-5, 1.0\nlaser = Laser(PlaneWave3D(), s, Δ; polarization=[1,0,0])\n\nproblem_scalar = LinearOptics(Scalar(), atoms, laser)\nu0 = default_initial_condition(problem_scalar)\ntspan = (0.0, 10.0)\nsolutions = time_evolution(problem_scalar, u0, tspan)\nstates = solutions.u\n\nθ = deg2rad(48)\nget_intensity_over_an_angle(problem_scalar, states, θ)\n\n\n\n\n\n","category":"function"},{"location":"spectrum/spectrum/#Spectrum","page":"Spectrum","title":"Spectrum","text":"","category":"section"},{"location":"spectrum/spectrum/","page":"Spectrum","title":"Spectrum","text":"You can use eigenvalues and eigenvectors to diagonalize the interaction_matrix. Typically, you are interested in the eigenvalues because their real and imaginary parts correspond to energy shifts and effective decay rates for different modes. Since the multiplicative constants in the interaction_matrix affect how you interpret the real and imaginary parts, use the spectrum function to avoid confusion.","category":"page"},{"location":"spectrum/spectrum/","page":"Spectrum","title":"Spectrum","text":"The figure below showcase the spectrum of the simulation in localizaed regime (rho  01) next to some spatial profiles.","category":"page"},{"location":"spectrum/spectrum/","page":"Spectrum","title":"Spectrum","text":"(Image: Alt text)","category":"page"},{"location":"spectrum/spectrum/","page":"Spectrum","title":"Spectrum","text":"using CoupledDipoles, CairoMakie, Random\n\nN, ρ = 2500, 0.3\nRandom.seed!(16)\natoms = Atom(CoupledDipoles.Cube(), cube_inputs(N, ρ)...)\n\nw₀, s, Δ = 4π, 1e-5, 0.0\nlaser = Laser(Gaussian3D(w₀), s, Δ)\n\nprob = LinearOptics(Scalar(), atoms, laser)\nmodes = classify_modes(prob)\n\nωₙ, Γₙ = spectrum(prob)\n\n# best case examples\nloc_idx = modes.loc[end]\nsub_idx = modes.sub[500]\nsuper_idx = modes.super[100]\n\nbegin\n    fig = Figure(size=(1200, 800))\n\n    # Main spectrum plot\n    ax_main = Axis(fig[1:3, 1:2],\n        xlabel=L\"\\omega/\\Gamma\",\n        ylabel=L\"\\Gamma_n/\\Gamma\",\n        xscale=identity,\n        yscale=log10,\n        xlabelsize=20,\n        ylabelsize=20,\n        xticklabelsize=16,\n        yticklabelsize=16)\n\n    labels = [\"Localized\", \"Sub radiant\", \"Super radiant\"]\n    shapes = [:rect, :circle, :cross]\n    # spectrum\n    for (i, mode) in enumerate(modes)\n        scatter!(ax_main, ωₙ[mode], Γₙ[mode],\n            label=labels[i],\n            markersize=15,\n            marker=shapes[i])\n    end\n\n    # indicate selected modes\n    mode_indices = [loc_idx, sub_idx, super_idx]\n    for (i, idx) in enumerate(mode_indices)\n        scatter!(ax_main, [ωₙ[idx]], [Γₙ[idx]],\n            marker=shapes[i],\n            color=:black,\n            markersize=30)\n    end\n    Legend(fig[0, 1:2], ax_main, orientation=:horizontal, labelsize=20)\n\n    # Spatial profile\n    for (i, idx) in enumerate(mode_indices)\n        DCM, ψ² = spatial_profile_single_mode(prob, idx)\n        ax = Axis(fig[i, 3], yscale=log10,\n            xlabel=L\"|\\mathbf{r} - \\mathbf{r}_{cm}|\",\n            ylabel=L\"|\\Psi|^2\",\n            title=labels[i])\n        scatter!(ax, DCM, ψ², color=:grey)\n\n        x_used, y_used = select_points(DCM, ψ²)\n        scatter!(ax, x_used, y_used, color=:black)\n\n        A, B, y_fit = CoupledDipoles.linear_fit_robust(x_used, log10.(y_used))\n        lines!(ax, x_used, exp10.(y_fit), linestyle=:solid, linewidth=5, color=:red)\n    end\n\n    fig\nend\n\nsave(\"modes_comparison.png\", fig)","category":"page"},{"location":"spectrum/spectrum/#Faster-eigenvalues/eigenvectors","page":"Spectrum","title":"Faster eigenvalues/eigenvectors","text":"","category":"section"},{"location":"spectrum/spectrum/","page":"Spectrum","title":"Spectrum","text":"Verify on your machine if you have some extra performance boost using MKL version provided by the numpy.","category":"page"},{"location":"spectrum/spectrum/","page":"Spectrum","title":"Spectrum","text":"I had not investigate the finding, just take note for future reference.","category":"page"},{"location":"spectrum/spectrum/","page":"Spectrum","title":"Spectrum","text":"using CoupledDipoles\nN, ρk⁻³ = 1500, 1.0\natoms = Atom(CoupledDipoles.Sphere(), sphere_inputs(N, ρk⁻³)...)\n\ns, Δ = exp10(-5), 1.0\nlaser = Laser(PlaneWave3D(), s, Δ)\n\nprob = LinearOptics(Scalar(), atoms, laser)\n@time eigenvectors(prob;forceComputation=true);\n\nusing PyCall\nnp = pyimport(\"numpy\")\n@time begin \n    H = interaction_matrix(prob)\n    H_np = np.array(H)\n    eigen_values, eigen_vectors = np.linalg.eig(H_np)\nend;","category":"page"},{"location":"spectrum/spectrum/","page":"Spectrum","title":"Spectrum","text":"","category":"page"},{"location":"spectrum/spectrum/#CoupledDipoles.interaction_matrix","page":"Spectrum","title":"CoupledDipoles.interaction_matrix","text":"interaction_matrix(::LinearOptics)\n\nThe interaction matrix dependends on the dimension and model.\n\nFor Scalar/Vectorial in 3D check Eq 2.23 and Eq 2.26 of the Thesis: https://doi.org/10.11606/T.76.2024.tde-26012024-114225\n\n\n\n\n\n","category":"function"},{"location":"spectrum/spectrum/#CoupledDipoles.spectrum","page":"Spectrum","title":"CoupledDipoles.spectrum","text":"spectrum(problem; forceComputation=false)\n\nReturns ωₙ and  Γₙ which are imag(λ) and -real(λ) - where λ is eigenvalues of interaction matrix\n\nValues are cached, unless forceComputation=true\n\n\n\n\n\n","category":"function"},{"location":"spectrum/spectrum/#CoupledDipoles.eigenvalues","page":"Spectrum","title":"CoupledDipoles.eigenvalues","text":"eigenvalues(problem::LinearOptics;forceComputation=false)\n\nComputes eigenvalues of the interaction matrix\n\nExample:\n\nusing CoupledDipoles\nN, ρk⁻³ = 1200, 1.0\natoms = Atom(CoupledDipoles.Sphere(), sphere_inputs(N, ρk⁻³)...)\n\ns, Δ = exp10(-5), 1.0\nlaser = Laser(PlaneWave3D(), s, Δ)\n\nprob = LinearOptics(Scalar(), atoms, laser)\nλ = eigenvalues(prob)\n\n\n\n\n\n","category":"function"},{"location":"spectrum/spectrum/#CoupledDipoles.eigenvectors","page":"Spectrum","title":"CoupledDipoles.eigenvectors","text":"eigenvectors(problem::LinearOptics; forceComputation=false)\n\nComputes eigenvectors of the interaction matrix\n\nExample:\n\nusing CoupledDipoles\nN, ρk⁻³ = 1200, 1.0\natoms = Atom(CoupledDipoles.Sphere(), sphere_inputs(N, ρk⁻³)...)\n\ns, Δ = exp10(-5), 1.0\nlaser = Laser(PlaneWave3D(), s, Δ)\n\nprob = LinearOptics(Scalar(), atoms, laser)\nΨ = eigenvectors(prob)\n\n\n\n\n\n","category":"function"},{"location":"lasers/lasers/#Lasers","page":"Laser","title":"Lasers","text":"","category":"section"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"To drive interaction of the atomic cloud, one usually pump a Plane Wave of Gaussian Beam, therefore, you have the PlaneWave and Gaussian abstract types. In practive, as user, you will be dealing with their subtypes, the PlaneWave3D or Gaussian3D, but the most important object will be the Laser.","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"First an example with PlaneWave3D","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"s, Δ = 1e-5, 1.0 # good values\nlaser_plane = Laser(PlaneWave3D(), s, Δ)","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"For Gaussian3D you have to provide the beam waist","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"waist = 0.75*kL # there is no perfect value here\nlaser_gaussian = Laser(Gaussian3D(waist), s, Δ)","category":"page"},{"location":"lasers/lasers/#turn_off!","page":"Laser","title":"turn_off!","text":"","category":"section"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"If you need to turn off the pump, the function turn_off!(laser) does exactly what it imply, but you cannot turn on later - If you need the laser back, you have to make a copy of the original.","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"waist = 0.75*kL # there is no perfect value here\nlaser_gaussian = Laser(Gaussian3D(waist), s, Δ)\n\nturn_off!(laser_gaussian)","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"Here a complete example of switch on-off dynamics","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"using CoupledDipoles, Random\n\n# atom's settings\nN, ρk⁻³ = 500, 0.02\nN, kR = cube_inputs(N, ρk⁻³)\nRandom.seed!(1111)\natoms = Atom(CoupledDipoles.Sphere(), N, kR)\n\n# laser's settings\ns, Δ = 1e-5, -2.0\nlaser = Laser(Gaussian3D(kR / 2), s, Δ)\n\n# create a Scalar model\nscalar = LinearOptics(Scalar(), atoms, laser)\nss_scalar = steady_state(scalar) # use the laser to get the state state\n\n# swtich-off dynamics\ntspan = (0, 75.0) # interval extremas\nsaveat = range(tspan[1], tspan[2], length=100) # force states to saved on these times\n\nturn_laser_off!(scalar) # have a time evolution without a pump\nstates_off = time_evolution(scalar, ss_scalar, tspan; saveat=saveat)\n\n# get some property to vizualize\ndecay_power = map(states_off.u) do states\n    scattered_power(scalar, states)\nend\n\n# using CairoMakie\n# fig = Figure()\n# ax = Axis(fig[1,1], xlabel=\"time\", ylabel=\"power\", yscale=log10)\n# scatterlines!(ax, saveat, decay_power)\n# fig","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"(Image: Decay After Laser is Turn Off)","category":"page"},{"location":"lasers/lasers/#Cool-Image","page":"Laser","title":"Cool Image","text":"","category":"section"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"You can actually see the spatial profile of your laser with a volume slice","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":" using GLMakie, CoupledDipoles, LinearAlgebra\n\n## FIGURE COLORS\nmyBG = RGBf(6/255, 0, 26/255 )\nmyGridColor = RGBf(30/255, 0/255, 30/255 )\nsensor_color = RGBf(247/255, 94/255, 133/255)\nmyColor =  cgrad(  [RGBf(0, 81/255, 123/255 ),\n                    RGBf(0, 221/255, 236/255),\n                    RGBf(201/255,251/255,255/255)])\n\nmyColor =  cgrad(  [RGBf(4/255, 0, 21/255 ),\n                    RGBf(0, 81/255, 123/255 ),\n                    RGBf(0, 221/255, 236/255),\n                    RGBf(201/255,251/255,255/255)])\nfig = Figure( backgroundcolor=myBG, size=(800, 800),)\nax = Axis3(fig[1, 1], aspect = (1,1,1),)\n\nw₀, s, Δ = 1π, 1e-5, 0.5\nlaser = Laser(Gaussian3D(w₀), s, Δ)\n\nx = LinRange(-10, 10, 50)\ny = LinRange(-10, 10, 50)\nz = LinRange(-10, 10, 50)\n\nvol = [norm(laser_field(laser, [X, Y, Z])) for X ∈ x, Y ∈ y, Z ∈ z]\nplt = volumeslices!(ax, x, y, z, vol, colormap=myColor)\nplt[:update_yz][](25)\nplt[:update_xz][](50)\n\n\nfig\n","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"(Image: Decay After Laser is Turn Off)","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"","category":"page"},{"location":"lasers/lasers/#CoupledDipoles.PlaneWave3D","page":"Laser","title":"CoupledDipoles.PlaneWave3D","text":"PlaneWave3D()\n\n\n\n\n\n","category":"type"},{"location":"lasers/lasers/#CoupledDipoles.Gaussian3D","page":"Laser","title":"CoupledDipoles.Gaussian3D","text":"Gaussian3D(w₀)\n\nw₀ is the Beam Waist.\n\nPlease, avoid w₀ < 2λ (λ = 2π / k₀) \n\n\n\n\n\n","category":"type"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"For convenience, ","category":"page"},{"location":"lasers/lasers/#CoupledDipoles.Laser","page":"Laser","title":"CoupledDipoles.Laser","text":"Laser(pump, s, Δ, direction, polarization)\n\npump is e.g PlanweWave3D or Gaussian3D\ns: saturation on ressonance (used for raby_frequency = Γ √(s / 2))\nΔ: the detunning (laser - atomic frequency) \ndirection: Array is the propagation direction (default is [0,0,1])\npolarization: Array is the polarization direction (default is [0,0,0])\n\nNote that direction and polarization have to be orthogonal.\n\n\n\n\n\n","category":"type"},{"location":"variances_angles/rayleigh_variance/#Deviations-from-Rayleigh's-law","page":"Intensity Statistics","title":"Deviations from Rayleigh's law","text":"","category":"section"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"Our goal is to reproduce Figure 2 from the paper Cottier et all, 2019, where the authors studied the statistics of the scattered light, and found that the variance of the intensity distribution deviates from the expected Rayleigh's law.","category":"page"},{"location":"variances_angles/rayleigh_variance/#Step-1-Use-distributed-resources","page":"Intensity Statistics","title":"Step 1 - Use distributed resources","text":"","category":"section"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"This step is optional, but if you have a lot of memory of cpu cores, is a good ideia to use it. Since this is optional, if you don't have a cluster to test, just comment the lines related to addprocs","category":"page"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"using CairoMakie, LinearAlgebra\nusing Statistics: mean, var\nusing StatsBase: fit, normalize, Histogram\n\naddprocs(2; \n    exeflags=`--project=$(Base.active_project()) --threads 4`, \n    topology=:master_worker, \n    enable_threaded_blas=true\n)\n\n@everywhere begin\n    using CoupledDipoles, Random, Dagger\n\n    function produce_intensities(rep, N, L, w₀, s, Δ, sensors)\n        Random.seed!(1134 + rep)\n    \n        atoms = Atom(Cube(), N, L)\n        laser = Laser(Gaussian3D(w₀), s, Δ)\n        simulation = LinearOptics(Scalar(), atoms, laser)\n    \n        βₙ = steady_state(simulation)\n        intensities = scattered_intensity(simulation, βₙ, sensors; regime = :far_field)\n        return intensities\n    end\nend\n","category":"page"},{"location":"variances_angles/rayleigh_variance/#Step-2-Setup-Parameters","page":"Intensity Statistics","title":"Step 2 - Setup Parameters","text":"","category":"section"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"We use the exact configuration parameters from the paper. You will notice may Warning messages. This happen because a small laser waist leads to unreasonable results.","category":"page"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"If you are studying Cottier's paper, note that the results from the paper are not accurate due to its small laser waist, even though they general paper's message is still correct.","category":"page"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"### ------------ ATOMS SPECS ---------------------\nL = 32.4\nN = [684, 6066]\n\n\n### ------------ LASER SPECS ---------------------\nΔ = 1.0\ns = 1e-6\nw₀ = L / 4\n\n### ------------ SIMULATION SPECS ---------------------\nsensors = get_sensors_ring(; num_pts = 720, kR = 300, θ = 5π / 12)\nmaxRep = 15","category":"page"},{"location":"variances_angles/rayleigh_variance/#Step-3-Produce-Intensities","page":"Intensity Statistics","title":"Step 3 - Produce Intensities","text":"","category":"section"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"For each atom number N, create maxRep atomic configurations, compute their state states, and scattered light intensity. The normalization over the mean comes from the paper.","category":"page"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"all_intensities = map(N) do N\n    _intensities = map(1:maxRep) do rep\n        Dagger.@spawn produce_intensities(rep, N, L, w₀, s, Δ, sensors)\n    end\n\n    many_intensities = fetch.(_intensities)\n    many_intensities = reduce(vcat, many_intensities)\n    all_intensities_over_mean = many_intensities ./ mean(many_intensities)\n\n    all_intensities_over_mean\nend;\n","category":"page"},{"location":"variances_angles/rayleigh_variance/#Step-4-Histograms","page":"Intensity Statistics","title":"Step 4 -  Histograms","text":"","category":"section"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"Instead of ploting histogram for each particle number, we are interested in the data from the histogram to display it in a scatter plot. Also, this is the moment to compute the variance of all intensities.","category":"page"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"bins = 10.0 .^ range(log10(1e-6), log10(75); length = 30)\n\nxy_data = map(eachindex(N)) do n\n    h = fit(Histogram, all_intensities[n], bins)\n\n    h_norm = normalize(h; mode = :pdf)\n    bins_edges = collect(h_norm.edges[1])\n    bins_centers = [sqrt(bins_edges[i] * bins_edges[i+1]) for i = 1:(length(bins_edges)-1)]\n    variance = var(all_intensities[n])\n\n    # x_data_histogram, y_data_histogram, variance\n    (bins_centers, h_norm.weights, variance)\nend","category":"page"},{"location":"variances_angles/rayleigh_variance/#Step-5-Plot","page":"Intensity Statistics","title":"Step 5 - Plot","text":"","category":"section"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"Overlay the Distribution Probability in a single figure.","category":"page"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"The begin-end structure is just to facilitate the Figure development for the user. It is easier to just run the block at once at every little plot tweak, than select and run everything all the time.","category":"page"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"begin\n    fig = Figure(size = (800, 450))\n    ax = Axis(\n        fig[1, 1],\n        xlabel = \"Intensity\",\n        ylabel = \"Probability Distribution\",\n        title = \"\",\n        xlabelsize = 25,\n        ylabelsize = 25,\n        xticklabelsize = 20,\n        yticklabelsize = 20,\n        xscale = log10,\n        yscale = log10,\n    )\n\n    ## theoretical curve\n    x_ray = range(0.01, 50; step = 0.15)\n    y_ray = exp.(-x_ray)\n    lines!(ax, x_ray, y_ray, linestyle = :dash, label = \"Rayleigh\", color = :black, linewidth = 4)\n\n    for n = 1:2\n        x = xy_data[n][1]\n        y = xy_data[n][2]\n        v = xy_data[n][3] # variance\n        notNull = findall(y .> 0)\n        scatter!(\n            ax,\n            x[notNull],\n            y[notNull];\n            label = \"N=$(N[n]), Variance = $( round(v,digits=3 ))\",\n            marker = :circle,\n            markersize = 20,\n        )\n    end\n    ylims!(1e-6, 10)\n    xlims!(1e-1, 100)\n    axislegend(position = :rt, labelsize = 20)\n    CairoMakie.save(\"rayleigh_deviation.png\", fig)\n    fig\nend","category":"page"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"(Image: Rayleigh Deviation)","category":"page"},{"location":"create_atoms/atoms/#Creating-Atoms","page":"Atom","title":"Creating Atoms","text":"","category":"section"},{"location":"create_atoms/atoms/#Default-distributions","page":"Atom","title":"Default distributions","text":"","category":"section"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"Currently, the package only supports 3D objects, namely Sphere, Cube, and Cylinder. However, the source code allows to extend functionalities to 1D and 2D in future developments - please, collaborate with a pull request. ","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"To create atoms, use the Atom constructor, the base syntax is the following","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"using CoupledDipoles, Random\nRandom.seed!(2354)\nnAtoms = 5000\n\n# `CoupledDipoles` and `CairoMakie` expoerts 'Sphere()', \n# therefore I had to be specific and write `CoupledDipoles.Sphere()`\nsphere_radius = 1.5\nsphere_cloud = Atom(CoupledDipoles.Sphere(), nAtoms, sphere_radius)\n\ncube_side = 1.0\ncube_cloud = Atom(Cube(), nAtoms, cube_side)\n\ncylinder_radius = 0.5\ncylinder_height = 2.0\ncylinder_cloud = Atom(Cylinder(), nAtoms, cylinder_radius, cylinder_height)","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"You just created a matrix with the atoms. The atoms positions are in Cartesian Coordinates, and stored in column-major (each column correspond to an atom).","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"To see your atoms you need have to plot them with some external package","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"using CairoMakie\nfig = Figure(size = (800, 300))\nax_sphere = Axis3(fig[1:2, 1:2], aspect = (1, 1, 1))\nax_cube = Axis3(fig[1:2, 3:4], aspect = (1, 1, 1))\nax_cylinder = Axis3(fig[1:2, 5:6], aspect = (1, 1, 1))\n\nsx, sy, sz = sphere_cloud.r[1, :], sphere_cloud.r[2, :], sphere_cloud.r[3, :]\nscatter!(ax_sphere, sx, sy, sz, color = sz)\n\ncx, cy, cz = cube_cloud.r[1, :], cube_cloud.r[2, :], cube_cloud.r[3, :]\nscatter!(ax_cube, cx, cy, cz, color = cz)\n\ncyx, cyy, cyz = cylinder_cloud.r[1, :], cylinder_cloud.r[2, :], cylinder_cloud.r[3, :]\nscatter!(ax_cylinder, cyx, cyy, cyz, color = cyz)\n\nhidedecorations!(ax_sphere)\nhidedecorations!(ax_cube)\nhidedecorations!(ax_cylinder)\nfig\n\nsave(\"geometries.png\", fig)","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"(Image: 3D examples)","category":"page"},{"location":"create_atoms/atoms/#User-defined-geometry","page":"Atom","title":"User defined geometry","text":"","category":"section"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"The Atom constructor holds the shape used for multiple-dispatch on the right physical equation, r is the matrix containg the atomic positions, N is the number of atom, and sizes is a generic radius for the system.","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"struct Atom{T<:Dimension}\n    shape::T\n    r::Matrix{Float64}\n    N::Int64\n    sizes::Any\nend","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"If a user wants to create their own atomic configuration, there are two constraints to consider:","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"The shape field can be handled easily by choosing one of the available options: Sphere, Cube, or Cylinder.\nThe matrix containing the atom positions must have each Cartesian dimension represented by a row.","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"Here's an example code snippet demonstrating the creation of a custom atomic configuration:","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"# Define atom positions as separate arrays\natom_1 = [1, 1, 1]\natom_2 = [2, 2, 2]\natom_3 = [3, 3, 3]\natom_4 = [4, 4, 4]\n\n# Combine atom positions into a single matrix\nr = transpose(vcat(atom_1, atom_2, atom_3, atom_4))\n# Note: The `transpose` function is used to fulfill the matrix constraint.\n\n# Convert the transposed result to an actual matrix using `Array`\nr = Array(r)\n# Note: The `transpose` operation returns a non-matrix object, so we use `Array` to materialize it.\n\n# Create the `Atom` object with the chosen shape and custom positions\ndummy_dimension = 5\natoms = Atom(Cube(), r, dummy_dimension)","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"The usage of transpose, followed by Array, is necessary to adhere to the package internals expectations.","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"Another example on how to concatenate vectors.","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"# (...)\nnAtoms = 5000\nx = 0.5randn(nAtoms)\ny = 0.5randn(nAtoms)\nz = 2rand(nAtoms)\nr  = hcat(x,y,z) |> transpose |> Array\n\n\ndummy_radius = 0.5\ndummy_height = 2.0\natoms = Atom(Cylinder(), r, dummy_radius, dummy_height)\n\nfig = Figure(size = (450, 450))\nax_sphere = Axis3(fig[1, 1])\nsx, sy, sz = atoms.r[1, :], atoms.r[2, :], atoms.r[3, :]\nscatter!(ax_sphere, sx, sy, sz, color = sz)    \nhidedecorations!(ax_sphere)\nfig","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"(Image: Gaussian Cylinder)","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"","category":"page"},{"location":"create_atoms/atoms/#CoupledDipoles.Sphere","page":"Atom","title":"CoupledDipoles.Sphere","text":"    Sphere(; gaussian=false)\n\nIf gaussian=true, produces a Gaussian Sphere with μ = 0 (mean = 0) and variance = kR (σ^2 = kR)\n\n\n\n\n\n","category":"type"},{"location":"create_atoms/atoms/#CoupledDipoles.Cube","page":"Atom","title":"CoupledDipoles.Cube","text":"    Cube()\n\n\n\n\n\n","category":"type"},{"location":"create_atoms/atoms/#CoupledDipoles.Cylinder","page":"Atom","title":"CoupledDipoles.Cylinder","text":"    Cylinder()\n\n\n\n\n\n","category":"type"},{"location":"create_atoms/atoms/#CoupledDipoles.Atom","page":"Atom","title":"CoupledDipoles.Atom","text":"Atom(geometry::Cube, N::Int64, kL::Union{Real,Integer}; r_min)\n\nArguments\n\ngeometry::Cube: The geometry of the atom object, which should be a Cube.\nN::Int64: The number of atoms.\nkL::Union{Real,Integer}: Cube's side length.\n\nKeyword Arguments\n\n:r_min: Optional keyword argument specifying the minimum distance between atoms.\n\nBy default it is computed with the radius_of_exclusion() method\n\nExample\n\natom = Atom(Cube(), 100, 5.0; r_min = 0.1)\n\n\n\n\n\nAtom(geometry::Cylinder, N::Int64, R::Union{Real,Integer}, h::Union{Real,Integer}; r_min)\n\nArguments\n\ngeometry::Cylinder: The geometry of the atom object, which should be a Cylinder.\nN::Int64: The number of atoms.\nR::Union{Real,Integer}: The radius of the cylinder.\nh::Union{Real,Integer}: The height of the cylinder.\n\nKeyword Arguments\n\n:r_min: Optional keyword argument specifying the minimum distance between atoms.\n\nBy default it is computed with the radius_of_exclusion() method\n\nExample\n\natom = Atom(Cylinder(), 100, 5.0, 10.0; r_min = 0.1)\n\n\n\n\n\nAtom(geometry::Sphere, N::Int64, kR::Union{Real,Integer}; kwargs...)\n\nArguments\n\ngeometry::Sphere: The geometry of the atom object, which should be a Sphere.\nfor Gaussian distribution, set gaussian=true\nN::Int64: The number of atoms.\nkR::Union{Real,Integer}: The radius for the sphere.\n\nKeyword Arguments\n\n:r_min: Optional keyword argument specifying the minimum distance between atoms. \n\nBy default it is computed with the radius_of_exclusion() method\n\nExample\n\natom_homogenous = Atom(Sphere(), 100, 5.0; r_min = 0.1)\natom_gaussian = Atom(Sphere(gaussian=true), 100, 5.0; r_min = 0.1)\n\n\n\n\n\n","category":"type"},{"location":"dipole_example/single_atom_volume/#Single-Atom","page":"Single Atom","title":"Single Atom","text":"","category":"section"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"The special case of a single atom is the radiation pattern of a dipole, defined in electromagnetism books.","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"To create a single atom system, set N=1. Note that all functions will output a Matrix of 1 element. This was an intentional decision to make internal functions interoperate effectively - if all inputs were a matrix, there was no ambiguity about the number of particles.","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"We need to use the Vectorial model to best visualize the radiation pattern. The code below is a minimal working example for checking the radiation pattern through a volume slice. The laser will be pointing in the negative x-direction, to make the visualization clearer.","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"using CoupledDipoles, Random\n\n# cloud settings\nN = 1\nkR = 10\n\n# laser settings\nw₀ = 4π\ns = 1e-5\nΔ = 0.0\n\nRandom.seed!(2044)\nsingle_atom =Atom(CoupledDipoles.Cylinder(), N, kR, kR)\nlaser = Laser(Gaussian3D(w₀), s, Δ; direction=[-1,0,0], polarization=[0,0,1])\nproblem = LinearOptics(Vectorial(), single_atom, laser)\nβₙ = steady_state(problem)","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"We had to apply :near_field regime manually to compute the intensity, because the default regime is :far_field. To evaulate the intensity in a certain spatial domain, we  use a list comprehension.","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"x = LinRange(-100, 100, 100)\ny = LinRange(-100, 100, 100)\nz = LinRange(-100, 100, 100)\n\n## this plot only works for near field regime\n_vol = [laser_and_scattered_intensity(problem, βₙ, Matrix([X Y Z]');regime=:near_field)[1] for X ∈ x, Y ∈ y, Z ∈ z]\nlaserOn = log10.(_vol)\n\n_vol = [scattered_intensity(problem, βₙ, Matrix([X Y Z]');regime=:near_field)[1] for X ∈ x, Y ∈ y, Z ∈ z]\nlaserOff = log10.(_vol)","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"In the following, the figures represents the radiation in space for single atom and the color range was choosen ad hoc to higlight the expected dipole radiation pattern.","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"using ColorSchemes\nusing GLMakie\n\n\nfig = Figure(resolution = (800, 600))\nax_on = Axis3(fig[1, 1], title = \"Dipole Radiation\", aspect=:data)\n\non_plt = volumeslices!(ax_on, x, y, z, laserOff,\n    colormap=cgrad( ColorSchemes.linear_kryw_0_100_c71_n256, rev=false),\n    colorrange=(-10, -7.5)\n    )\non_plt[:update_yz][](100)\non_plt[:update_xz][](50)\non_plt[:update_xy][](1)\n\nfig\n","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"(Image: Dipole Radiation)","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"Now a comparison between with laser on and off","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"fig = Figure(size = (900, 800), background_color=:transparent)\n    ax_on = Axis3(fig[1, 1], title = \"Laser On\", aspect=:data)\n    ax_off = Axis3(fig[1, 2], title = \"Laser Off\", aspect=:data)\n\n    on_plt = volumeslices!(ax_on, x, y, z, laserOn,\n        colormap=cgrad( ColorSchemes.linear_kryw_0_100_c71_n256, rev=false),\n        colorrange=(-10, -7.5)\n        )\n    on_plt[:update_yz][](100)\n    on_plt[:update_xz][](50)\n    on_plt[:update_xy][](1)\n\n    off_plt = volumeslices!(ax_off, x, y, z, laserOff,\n        colormap=cgrad( ColorSchemes.linear_kryw_0_100_c71_n256, rev=false),\n        colorrange=(-10, -7.5)\n        )\n    off_plt[:update_yz][](100)\n    off_plt[:update_xz][](50)\n    off_plt[:update_xy][](1)\n\n    cbar = Colorbar(fig, off_plt; label=\"log10( Intensity )\", flipaxis=false,  vertical = false, width = Relative(4/5),ticks=WilkinsonTicks(3))\n    fig[2, :] = cbar\n\n    # save(\"on_off_radiation.png\", fig)\n    fig","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"(Image: Laser On and Off)","category":"page"},{"location":"localization/spatial_modes/#Localization","page":"Spatial Profile","title":"Localization","text":"","category":"section"},{"location":"localization/spatial_modes/","page":"Spatial Profile","title":"Spatial Profile","text":"How to verify if a mode is localized or not is, at ultimate case, a visual inspection task. In 3D this task is particually challenging to understand and interpret. For instance, we could for instance scale the color of size of each marker accoriding to Psi_j^2, which is shown in figures (a)-(c). ","category":"page"},{"location":"localization/spatial_modes/","page":"Spatial Profile","title":"Spatial Profile","text":"However, a better approach is to define the distance of the atoms from the mode's center of mass, using Psi_j^2 as weights, the results are show in (d)-(f) .The function spatial_profile_single_mode provides that for you.","category":"page"},{"location":"localization/spatial_modes/","page":"Spatial Profile","title":"Spatial Profile","text":"Verifying if a mode is localized or not is primarily a visual inspection task. In 3D, this task can be particularly challenging to understand and interpret. For example, we could scale the color or size of each marker according to Psi_j^2, as shown in figures (a)-(c). A more clear visualization is to define the distance of the atoms from the mode’s center of mass, using Psi_j^2 as weights. The results are shown in figures (d)-(f). The function spatial_profile_single_mode provides this for you.","category":"page"},{"location":"localization/spatial_modes/","page":"Spatial Profile","title":"Spatial Profile","text":"Another approach is to check the Inverse Participation Ratio, IPR, which you can also access them via get_IPRs.","category":"page"},{"location":"localization/spatial_modes/","page":"Spatial Profile","title":"Spatial Profile","text":"(Image: Alt text)","category":"page"},{"location":"localization/spatial_modes/","page":"Spatial Profile","title":"Spatial Profile","text":"using CoupledDipoles, Random, FileIO, CairoMakie, ColorSchemes\n\nN, ρk⁻³ = 2000, 1.0\nRandom.seed!(1135)\natoms = Atom(CoupledDipoles.Sphere(), sphere_inputs(N, ρk⁻³)...)\n\ns, Δ = exp10(-5), 1.0\nlaser = Laser(PlaneWave3D(), s, Δ)\n\nprob = LinearOptics(Scalar(), atoms, laser)\nmodes = classify_modes(prob) # this functions is likely to suffer changes on its classification algorithm\n\n\nfig = with_theme(theme_latexfonts()) do\n    cmap = cgrad(colorschemes[:tableau_red_black_white], 15, categorical = true, rev=false)\n    xs, ys, zs = prob.atoms.r[1, :], prob.atoms.r[2, :], prob.atoms.r[3, :]\n    loc_idx = modes.loc[end-5]\n    sub_idx = modes.sub[4]\n    super_idx = modes.super[4]\n\n    fig = Figure(size = (900, 450), fontsize=20)\n    axs_3d = [Axis3(\n            fig[1,i],\n            xlabel = L\"x\",\n            ylabel = L\"y\",\n            zlabel = L\"z\",\n            aspect = (1,1,1)\n        ) for i in 1:3]\n    axs_2d = [Axis(\n            fig[2,i],\n            xlabel = L\"|\\mathbf{r}_j - \\mathbf{r}_{cm}|\",\n            ylabel = L\"|\\psi|^2\",\n            aspect = 1,\n            yscale=log10,\n            xticks = WilkinsonTicks(4),\n        ) for i in 1:3]\n\n    for (ax_3d, ax_2d, figIdx, title) in zip(axs_3d, axs_2d, [loc_idx, sub_idx, super_idx], [\"LOC\",\"SUB\",\"SUPER\"])\n        ax_3d.title = title\n\n        x, y = spatial_profile_single_mode(prob, figIdx)\n        ynorm = (y .- minimum(y))./(maximum(y) - minimum(y)) # normalization between 0 and 1 for vizualization only\n\n        ψ²ₙ = CoupledDipoles.get_ψ²(prob, figIdx) # I could use `eigenvectors(prob)` to select the mode I want\n        r_cm = CoupledDipoles.coordinates_of_center_of_mass(prob.atoms.r, ψ²ₙ )\n\n        # (a) - (c)\n        scatter!(ax_3d, xs, ys, zs, markersize = 20ynorm, color = ynorm, transparency=true, colormap=cmap )\n        scatter!(ax_3d, [r_cm[1]], [r_cm[2]], [r_cm[3]], markersize = 25, color = \"#5b8fbc\", marker=:xcross)\n\n        # (d) - (f)\n        scatter!(ax_2d, x, y, markersize = 10, color = ynorm, transparency=false, colormap=cmap )\n        ylims!(ax_2d, 1e-15, 10)\n    end\n\n    for (label, layout) in zip([\"(a)\", \"(b)\", \"(c)\", \"(d)\", \"(e)\",\"(f)\"], [fig[1,1], fig[1,2], fig[1,3], fig[2,1],fig[2,2],fig[2,3]])\n\t\tLabel(layout[1, 1, TopLeft()], label,\n\t\t\tfontsize = 15,\n\t\t\tfont = :bold,\n\t\t\tcolor=:black,\n\t\t\tpadding = (0, 5, 5, 0),\n\t\t\t)\n\tend\n\n    fig\nend\n\nFileIO.save(\"modesComparison.png\", fig)","category":"page"},{"location":"localization/spatial_modes/","page":"Spatial Profile","title":"Spatial Profile","text":"","category":"page"},{"location":"localization/spatial_modes/#CoupledDipoles.classify_modes","page":"Spatial Profile","title":"CoupledDipoles.classify_modes","text":"classify_modes(problem)\n\nReturns a tuple (loc, sub, super) with indices.\n\n\n\n\n\n","category":"function"},{"location":"localization/spatial_modes/#CoupledDipoles.spatial_profile_single_mode","page":"Spatial Profile","title":"CoupledDipoles.spatial_profile_single_mode","text":"spatial_profile_single_mode(problem, mode_index::Integer)\n\nReturns DCM, ψ²ₙ, that is, the Distance of atoms to the center of mass, and the absolute value of the mode.\n\n\n\n\n\n","category":"function"},{"location":"localization/spatial_modes/#CoupledDipoles.get_IPRs","page":"Spatial Profile","title":"CoupledDipoles.get_IPRs","text":"get_IPRs(problem; forceComputation=false)\n\nInverse Participation Ratio is computed with ∑Ψ⁴ / ( ∑Ψ² )² for each mode\n\n\n\n\n\n","category":"function"},{"location":"localization/spatial_modes/#CoupledDipoles.get_PRs","page":"Spatial Profile","title":"CoupledDipoles.get_PRs","text":"get_PRs(problem; forceComputation=false)\n\nParticipation Ratio is computed with ( ∑Ψ² )² / ∑Ψ⁴ for each mode\n\n\n\n\n\n","category":"function"},{"location":"time_evolution/time_evolution/#Time-Evolution","page":"Time Evolution","title":"Time Evolution","text":"","category":"section"},{"location":"time_evolution/time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"The equations for time evolution depend on the model. For 3D models, these equations are detailed in Chapter 2 of the Thesis.","category":"page"},{"location":"time_evolution/time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"To use the time_evolution method, you only need to provide the problem and detuning range. This method outputs a tuple of the atomic states containing time stamps (atomic_states.t) and atomic states (atomic_states.u). It relies on the OrdinaryDiffEq package, allowing you to control the solver directly if needed.","category":"page"},{"location":"time_evolution/time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"(Image: Alt text)","category":"page"},{"location":"time_evolution/time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"using CoupledDipoles, CairoMakie, Random\n\nN, ρ = 25, 0.1\nRandom.seed!(16)\natoms = Atom(CoupledDipoles.Sphere(), sphere_inputs(N, ρ)...)\n\nw₀, s, Δ = 4π, 1e-5, 0.0\nlaser = Laser(Gaussian3D(w₀), s, Δ)\nprob = NonLinearOptics(MeanField(), atoms, laser)\n\nu₀ = default_initial_condition(prob)\ntspan = (0, 150)\nsaveat = range(tspan[1], tspan[2], length=100) # force states to saved on these times\nstates_on = time_evolution(prob, u₀, tspan; saveat=saveat)\n\nθ = deg2rad(75)\nintensity_on = get_intensity_over_an_angle(prob, states_on.u, θ)\n\n\nfig = Figure(size=(800, 600))\nax = Axis(fig[1, 1],\n    xlabel=\"time [1/Γ]\",\n    title=\"Average Intensity at θ = $(round(θ, digits=2)) rad\",\n    xlabelsize=20,\n    ylabelsize=20,\n    xticklabelsize=16,\n    yticklabelsize=16\n)\n\nlines!(ax, saveat, intensity_on, label=\"\", linewidth=4)\ndisplay(fig)\n\n\nsave(\"time_evolution.png\", fig)","category":"page"},{"location":"time_evolution/time_evolution/","page":"Time Evolution","title":"Time Evolution","text":"","category":"page"},{"location":"time_evolution/time_evolution/#CoupledDipoles.time_evolution","page":"Time Evolution","title":"CoupledDipoles.time_evolution","text":"time_evolution(problem::LinearOptics{T}, u₀, tspan::Tuple; ode_solver=true, interaction::Matrix=interaction_matrix(problem), kargs...) where {T<:Linear}\n\nu₀ can be obtained via default_initial_condition function\ntspan is a tuple with (start, end) times\node_solver indicates to use the Ordinary Differential Equation package, if set to false, use eigendecompostion to compute the states (which is slow)\ninteraction is the interaction matrix used on the time evolution\nkargs are arguments that you use on the OrdinaryDiffEq.solve method directly\n\n\n\n\n\ntime_evolution(problem::NonLinearOptics{T}, u₀, tspan::Tuple; kargs...)\n\nSimilar behavior tot the LinearOptics model, but does not have arguments related to the formal solution (obtained via diagonalization)\n\n\n\n\n\n","category":"function"},{"location":"transmission/transmission/#Transmission","page":"Transmission","title":"Transmission","text":"","category":"section"},{"location":"transmission/transmission/","page":"Transmission","title":"Transmission","text":"The transmission analysis is among the top three most challenging to implement correctly. A single incorrect constant can result in transmission values exceeding one.","category":"page"},{"location":"transmission/transmission/","page":"Transmission","title":"Transmission","text":"The transmission method calculates the ratio of scattered intensity to laser intensity at a specific point (in far field distance). It requires a problem and a detuning range, from which it automatically computes the steady state.","category":"page"},{"location":"transmission/transmission/","page":"Transmission","title":"Transmission","text":"(Image: Alt text)","category":"page"},{"location":"transmission/transmission/","page":"Transmission","title":"Transmission","text":"# credits for Marcella Loyola Xavier\nusing CoupledDipoles, CairoMakie\n\n# cloud settings\nR, L = 17.7183099768, 8.177681527782\na, b, c = 0.1, 0.2, 0.3\n\nX = [a, a, -a, -a] .* R\nY = [b, -b, b, -b] .* R\nZ = [c, -c, -c, c] .* L\nr = vcat(X', Y', Z') |> Array # atom's position matrix\ndummy_dimension = R\ncloud = Atom(Cube(), r, dummy_dimension)\n\n# laser settings\nw₀, s = R / 3, 1e-5\npolarization_linear = [1, 0, 0]  # x-direction\npolarization_circular_positive = [1, +im, 0] ./ √2 \npolarization_circular_negative = [1, -im, 0] ./ √2\n\n# transmission\nbegin\n    Δ_range = range(-1, 1; length=50) \n    _Δ = 1.0*Δ_range[1] # for initialization purposes, I need some value\n\n    T = zeros(length(Δ_range), 3)\n    \n    \n    laser_lin = Laser(Gaussian3D(w₀), s, _Δ; polarization=polarization_linear)\n    problem_lin = LinearOptics(Vectorial(), cloud, laser_lin)\n    T[:, 1] = transmission(problem_lin, Δ_range)\n\n    laser_cir_p = Laser(Gaussian3D(w₀), s, _Δ; polarization=polarization_circular_positive)\n    problem_cir_p = LinearOptics(Vectorial(), cloud, laser_cir_p)\n    T[:, 2] = transmission(problem_cir_p, Δ_range)\n\n    laser_cir_n = Laser(Gaussian3D(w₀), s, _Δ; polarization=polarization_circular_negative)\n    problem_cir_n = LinearOptics(Vectorial(), cloud, laser_cir_n)\n    T[:, 3] = transmission(problem_cir_n, Δ_range)\n\n    fig = Figure(size=(800, 600))\n    ax = Axis(fig[1, 1],\n        xlabel=\"Δ\",\n        ylabel=\"Transmission\",\n        xlabelsize=20,\n        ylabelsize=20,\n        xticklabelsize=16,\n        yticklabelsize=16\n    )\n\n    lines!(ax, Δ_range, T[:, 1], label=\"[1, 0, 0]\", linewidth=4)\n    lines!(ax, Δ_range, T[:, 2], label=\"[1, +im, 0] / √2\", linewidth=3, linestyle=:dot)\n    lines!(ax, Δ_range, T[:, 3], label=\"[1, -im, 0] / √2\", linewidth=3, linestyle=:dash)\n    axislegend(ax, \"Polarization\", position=:rb, orientation=:vertical, labelsize=20)\n\n    fig\nend\n\nsave(\"transmission.png\", fig)","category":"page"},{"location":"transmission/transmission/","page":"Transmission","title":"Transmission","text":"","category":"page"},{"location":"transmission/transmission/#CoupledDipoles.transmission","page":"Transmission","title":"CoupledDipoles.transmission","text":"transmission(problem, detunning_range::AbstractArray; regime=:near_field)\n\nOne point is created at far_field_distance = 100*size(problem.atoms) in any direction. Then, transmission (Intensity Scattered over Intensity Laser) is evaluated with on steady state (computed automatically) for different detunnings.\n\n\n\n\n\n","category":"function"},{"location":"#CoupledDipoles.jl","page":"Home","title":"CoupledDipoles.jl","text":"","category":"section"},{"location":"#**Installation**","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is package is not registred in julia, you have to use its github URL","category":"page"},{"location":"","page":"Home","title":"Home","text":"Due to its many dependencies, the installation process may take around 10 minutes and requires at least 16Gb of RAM on your device","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\n# Pkg.add(\"MKL\") # (if installation goes wrong, run this line, and try to install again)\nPkg.add(url=\"https://github.com/NoelAraujo/CoupledDipoles.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To verify that everything is working correctly, run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CoupledDipoles\n# Pkg.test(\"CoupledDipoles\")","category":"page"},{"location":"#First-Example","page":"Home","title":"First Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's create a problem with N=1000 atoms inside a Cube of size kR=40, pumped by a laser with saturation s=1e-6 and on resonance Δ=0. We'll use the Atom and Laser constructors to define the problem, and then create a Scalar Model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"From the problem you get, for example, the steady_state","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CoupledDipoles\nN, kR = 1000, 40\natoms = Atom(Cube(), N, kR)\n\ns, Δ = 1e-6, 0.0\nlaser = Laser(PlaneWave3D(), s, Δ)\nproblem = LinearOptics(Scalar(), atoms, laser)\nβₛₛ = steady_state(problem)","category":"page"},{"location":"#Cool-image","page":"Home","title":"Cool image","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check an atomic cloud pumped by a laser, and surrounded by a ring of sensors, where some scattered property can be measured.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Figure 1 of the thesis)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is the code","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GLMakie, CoupledDipoles, LinearAlgebra, Random\n\n## FIGURE COLORS\nmyBG = RGBf(6/255, 0, 26/255 )\nmyGridColor = RGBf(30/255, 0/255, 30/255 )\nsensor_color = RGBf(247/255, 94/255, 133/255)\nmyColor =  cgrad(  [\n    RGBf(0, 81/255, 123/255 ),\n    RGBf(0, 221/255, 236/255),\n    RGBf(201/255,251/255,255/255)\n    ]\n)\n\n## DATA\nRandom.seed!(3456)\natoms = Atom(CoupledDipoles.Sphere(), 6000, 10)\nx_a, y_a, z_a = atoms.r[1, :], atoms.r[2, :], atoms.r[3, :]\n\nfig = let\n    myColor =  cgrad(  [RGBf(4/255, 0, 21/255 ),\n                        RGBf(0, 81/255, 123/255 ),\n                        RGBf(0, 221/255, 236/255),\n                        RGBf(201/255,251/255,255/255) ])\n    fig = Figure(; size=(1200, 1000), backgroundcolor=myBG, fontsize=25)\n    ax = Axis3(\n        fig[1, 1];\n        xlabel=\"X\",\n        ylabel=\"Y\",\n        zlabel=\"Z\",\n\n        zgridcolor=myGridColor,\n        xgridcolor=myGridColor,\n        ygridcolor=myGridColor,\n\n        ztickcolor=:white,\n        xtickcolor=:white,\n        ytickcolor=:white,\n\n        xlabelcolor=:white,\n        ylabelcolor=:white,\n        zlabelcolor=:white,\n        titlecolor=:white,\n\n        xgridwidth = 1,\n        ygridwidth = 1,\n        zgridwidth = 1,\n\n        backgroundcolor=myBG,\n        aspect = (1,1,1),\n\n        xticksvisible = false,\n        yticksvisible = false,\n        zticksvisible = false,\n\n        xticklabelsvisible = false,\n        yticklabelsvisible = false,\n        zticklabelsvisible = false,\n    )\n\n\n    w₀, s, Δ = 3π, 1e-5, 0.5\n    laser = Laser(Gaussian3D(w₀), s, Δ)\n\n    x = LinRange(-15, 15, 100)\n    y = LinRange(-15, 15, 100)\n    z = LinRange(-15, 15, 100)\n\n    vol = [norm(laser_field(laser, [X, Y, Z])) for X ∈ x, Y ∈ y, Z ∈ z]\n    plt = volumeslices!(ax, x, y, z, vol, colormap=myColor)\n    idx_slice = 40\n    plt[:update_yz][](99)\n    plt[:update_xz][](99)\n    plt[:update_xy][](1)\n    ## ATOMOS\n    validIdx = 1:6000\n    scatter!(ax, x_a[validIdx], y_a[validIdx], z_a[validIdx],\n        strokewidth=0.5, strokecolor=myGridColor,\n        color=z_a[validIdx], colormap=myColor, markersize=20)\n\n\n\n    ## LASER SHAPE\n    a = w₀/2  # Scaling factor along x-axis\n    b = w₀/2  # Scaling factor along y-axis\n    c = 12.0  # Scaling factor along z-axis\n\n    # Define the parametric equations for the 'hyperboloid'\n    u = LinRange(-1, 1, 50)\n    v = LinRange(0, 2 * pi, 50)\n    X = [a*cosh(u)*cos(v) for u in u, v in v]\n    Y = [b*cosh(u)*sin(v) for u in u, v in v]\n    Z = [c*sinh(u) for u in u, v in v]\n\n    surface!(ax, X, Y, Z; shading = Makie.automatic, \n        backlight = 1.0f0, color = sqrt.(X .^ 2 .+ Y .^ 2 .+ Z .^ 2),\n        colormap = myColor, transparency = false,\n        )\n    wireframe!(ax, X, Y, Z; linewidth = 0.5, transparency = true)\n\n\n    # SENSORES\n    sensors = get_sensors_ring(; num_pts = 64, kR = 15, θ = 5π / 12)\n    sx, sy, sz = sensors[1,:], sensors[2,:], sensors[3,:]\n    scatter!(ax, sx, sy,sz,color=sensor_color, markersize=20)\n\n\n    xlims!(ax, -15,15)\n    ylims!(ax, -15,15)\n    zlims!(ax, -15,15)\n    fig\nend","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
