var documenterSearchIndex = {"docs":
[{"location":"steady_state/#ss_page","page":"Steady State","title":"Steady State","text":"","category":"section"},{"location":"steady_state/#LinearOptics","page":"Steady State","title":"LinearOptics","text":"","category":"section"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"The time evolution of LinearOptics follows the equation:","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"fracdvecbetadt = Gvecbeta + vecOmega","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"which has a well-defined formal solution:","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"vecbeta_s = -G^-1vecOmega","category":"page"},{"location":"steady_state/#Scalar","page":"Steady State","title":"Scalar","text":"","category":"section"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"In the Scalar case, the soltuion is a Vector: ","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"using CoupledDipoles\nr =[1 2 0;\n    1 0 1.0]\natoms = Atom(Cube(), Array(transpose(r)), 10)\nlaser = Laser(PlaneWave3D(), 1e-6, 1.0)\nproblem = LinearOptics(Scalar(), atoms, laser)\nβₛ = steady_state(problem) # N-array","category":"page"},{"location":"steady_state/#Vectorial","page":"Steady State","title":"Vectorial","text":"","category":"section"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"In Vectorial case, one gets a Matrix:","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"each row represents the x,y,z-components of the polarization\neach colums correspond to different atoms","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"# (...) same as Scalar case\nproblem = LinearOptics(Vectorial(), atoms, laser)\nβₛ = steady_state(problem) # 3xN-matrix","category":"page"},{"location":"steady_state/#NonLinearOptics","page":"Steady State","title":"NonLinearOptics","text":"","category":"section"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"NonLinearOptics does not have a formal solution, therefore steady_state have two approaches","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"Use NewtonRaphson methods (default)\nIf ode_solver=true, use the time_evolution function over the period tspan = (0, 250) and return the final state","category":"page"},{"location":"steady_state/#MeanField","page":"Steady State","title":"MeanField","text":"","category":"section"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"The solution is a Vector of size 2N, corresponding to [langle sigma^- rangle langle sigma^z rangle].","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"# (...) same as Scalar case\nproblem = NonLinearOptics(MeanField(), atoms, laser)\nβₛ = steady_state(problem) # default with NewtonRaphson\n\nβₛ = steady_state(problem; ode_solver=true) # bruteforce time evoltuion","category":"page"},{"location":"steady_state/#PairCorrelation","page":"Steady State","title":"PairCorrelation","text":"","category":"section"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"The solution is a Vector of size 2N + 4N^2, corresponding to [sigma^- sigma^z sigma^zsigma^- sigma^+sigma^- sigma^-sigma^- sigma^zsigma^z].","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"# (...) same as Scalar case\nproblem = NonLinearOptics(PairCorrelation(), atoms, laser)\nβₛ = steady_state(problem) # default with NewtonRaphson\n\nβₛ = steady_state(problem; ode_solver=true) # bruteforce time evoltuion","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"","category":"page"},{"location":"steady_state/","page":"Steady State","title":"Steady State","text":"steady_state","category":"page"},{"location":"steady_state/#CoupledDipoles.steady_state","page":"Steady State","title":"CoupledDipoles.steady_state","text":"steady_state(problem::LinearOptics{Scalar})\n\nSolve x=-G\\Ω, with default interaction_matrix and laser_field.\n\n\n\n\n\nsteady_state(problem::LinearOptics{Vectorial})\n\nSolve x=-G\\Ω, with default interaction_matrix and laser_field. The solution x is reshaped as a 3xN matrix.\n\n\n\n\n\nsteady_state(problem::NonLinearOptics{MeanField}; tmax = 250.0, reltol = 1e-11, abstol = 1e-10, m = 90, ode_solver = false)\n\n\n\n\n\n","category":"function"},{"location":"linear_regression/linear_regression_methods/#Linear-Regression-with-Noise-Data","page":"Fitting","title":"Linear Regression with Noise Data","text":"","category":"section"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"The localization length comes from noise data, and one needs to pre process the data before extracting any analysis. In this section, we show how we use the package LinRegOutliers.jl for our application.","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"Localization length, xi, comes from the assumption that the data follows","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"y = A_0e^-xxi","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"However, the package LinRegOutliers.jl works best with linear functions, thus, we define","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"Y = ln(A_0) -xxi","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"or","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"Y = A + Bx","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"Our goal then becomes to identify xi = -1B.","category":"page"},{"location":"linear_regression/linear_regression_methods/#Exponential-with-Noise","page":"Fitting","title":"Exponential with Noise","text":"","category":"section"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"We will create some data and check for the methods avaiable on LinRegOutliers.jl that leads to best results. Our test function will be","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"y = 2234e^-x1345","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"and we add white noise at each point of the domain x","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"using Random\nRandom.seed!(1234)\n\nx = range(0, 5, length = 40)\ny = log.(2.234exp.(-x/1.345) .+ rand(length(x)) ./ 10)","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"Now, we will create a functin that returns the coeficientes of the linear fit. For that, we specify our @formula, the Dataframe with our data, and use one of the available methods on LinRegOutliers.jldocs.","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"using LinRegOutliers, DataFrames\nfunction linear_fit_robust(x, y; regression_method = lta)\n\treg = createRegressionSetting(@formula(y ~ x), DataFrame([:x => x, :y => y]))\n\tresult = regression_method(reg)\n\n\tA, B = result[\"betas\"]\n\ty_fit = A .+ (B .* x)\n\n\treturn A, B, y_fit\nend\n## test\nA, B, y_fit = linear_fit_robust(x, y)\nξ = -1/B","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"Now, we can test and visualize the fitting result","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"using CairoMakie\nscatter(x, y, axis=(xlabel=\"x\", ylabel=\"y\"))\nlines!(x, y_fit, color = Cycled(2), linewidth = 5, label=\"ξ = $( round(ξ, digits=3))\")\naxislegend()\ncurrent_figure()","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"(Image: )","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"","category":"page"},{"location":"linear_regression/linear_regression_methods/#Methods-Comparison","page":"Fitting","title":"Methods Comparison","text":"","category":"section"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"The exact metho depends on the level of noise on the data. On this specific example, the best regression method was the asm2000.","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"begin\n    fig = Figure()\n    ax = Axis(fig[1, 1], xlabel = \"x\", ylabel=\"y\")\n    scatter!(ax, x, y)\n\tmethods_list = [hs93, ks89, smr98, lms, lts, bch, py95, satman2013, satman2015,\n\t\tasm2000, lad, lta, galts, imon2005, ccf, cm97, quantileregression]\n    comparisons = []\n\tfor method in methods_list\n\t\ta, b, y_fit = linear_fit_robust(x, y; regression_method = method)\n        lines!(ax, x, y_fit, linewidth = 1, label = \"$(method)\")\n\n        comparison =  (-1/b)/1.345\n        push!(comparisons, comparison)\n\tend\n    value, idx  = findmin(comparisons)\n    println(\"$(methods_list[idx]) had the best fitting, with ξ = $(value*1.345)\")\n\n    Legend(fig[1, 2], ax)\n\tcurrent_figure()\nend","category":"page"},{"location":"linear_regression/linear_regression_methods/","page":"Fitting","title":"Fitting","text":"(Image: )","category":"page"},{"location":"problems/problems/#Problems","page":"Problem","title":"Problems","text":"","category":"section"},{"location":"problems/problems/","page":"Problem","title":"Problem","text":"Your simulation will only work if you change use the write problem data type, you are interested on the LinearOptics or NonLinearOptics constructors.","category":"page"},{"location":"problems/problems/","page":"Problem","title":"Problem","text":"For the LinearOptics you have the Scalar and Vectorial models, whereas the NonLinearOptics have MeanField and PairCorrelation. All of them deal with the 3 dimensions - different dimensions have different equations which are waiting for someone (not the author) to write them in the code engines.","category":"page"},{"location":"problems/problems/","page":"Problem","title":"Problem","text":"Here all the possible configurations.","category":"page"},{"location":"problems/problems/","page":"Problem","title":"Problem","text":"# settings\nN, kR = 15, 32.4\nw₀, s, Δ = 4π, 1e-5, 0.3   \natoms = Atom(CoupledDipoles.Sphere(gaussian=true), N, kL; r_min=0.0)\nlaser = Laser(Gaussian3D(w₀), s, Δ)\n\n# LinearOptics options\nprob_scalar = LinearOptics(Scalar(), atoms, laser)\nprob_vectorial = LinearOptics(Vectorial(), atoms, laser)\n\n# NonLinearOptics options\nprob_meanfield = NonLinearOptics(MeanField(), atoms, laser)\nprob_pair = NonLinearOptics(PairCorrelation(), atoms, laser)\n\n\n# (do something with your problem)\n# (...)","category":"page"},{"location":"problems/problems/","page":"Problem","title":"Problem","text":"","category":"page"},{"location":"problems/problems/","page":"Problem","title":"Problem","text":"LinearOptics","category":"page"},{"location":"problems/problems/#CoupledDipoles.LinearOptics","page":"Problem","title":"CoupledDipoles.LinearOptics","text":"LinearOptics(physic::Scalar, atoms, laser)\n\n\n\n\n\nLinearOptics(physic::Vectorial, atoms, laser)\n\n\n\n\n\n","category":"type"},{"location":"problems/problems/","page":"Problem","title":"Problem","text":"NonLinearOptics","category":"page"},{"location":"problems/problems/#CoupledDipoles.NonLinearOptics","page":"Problem","title":"CoupledDipoles.NonLinearOptics","text":"NonLinearOptics(physic::MeanField, atoms, laser)\n\n\n\n\n\nNonLinearOptics(physic::PairCorrelation, atoms, laser)\n\n\n\n\n\n","category":"type"},{"location":"scattering/#Scattering","page":"Scatttering","title":"Scattering","text":"","category":"section"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"The electric field measured at sensor positioned at mathbfR = Rhatn results from the sum of all  dipoles located at mathbfr_j and their respective states beta_j. The exact formula depends on the model and regime. By default, all scattering function are configured on :near_field regime. ","category":"page"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"Note: Only the Vectorial Model did not have sufficient tests to be considered reliable on the :far_field (but is considered correct with :near_field)","category":"page"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"","category":"page"},{"location":"scattering/#Electric-Field","page":"Scatttering","title":"Electric Field","text":"","category":"section"},{"location":"scattering/#Scalar","page":"Scatttering","title":"Scalar","text":"","category":"section"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :near_field","category":"page"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"E_sc(mathbfR t) = +ifracGamma2sum_j frace^ ik_0mathbfR - mathbfr_j k_0mathbfR - mathbfr_jbeta_j(t)","category":"page"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :far_field","category":"page"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"E_sc(mathbfR t) approx +ifracGamma2 frace^ ik_0R k_0Rsum_j exp( -ik_0hatn cdot mathbfr_j )beta_j(t)","category":"page"},{"location":"scattering/#Vectorial","page":"Scatttering","title":"Vectorial","text":"","category":"section"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :near_field","category":"page"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"E_vec(mathbfR t) = +iGammasum_jsum_etaG_mueta(mathbfR-mathbfr_j)beta_j^eta(t)","category":"page"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :far_field (NOT VALIDATED)","category":"page"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"E^mu_vec(mathbfRt) approx +ifrac3Gamma4 frace^ik_0Rk_0Rsum_jsum_eta(delta_mu eta - hatn_muhatn_eta^*)exp(-ik_0hatmathbfncdotmathbfr_j)beta_j^eta(t)","category":"page"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"If you have experience with this equation, please consider contributing to the package with benchamrks.","category":"page"},{"location":"scattering/#Mean-Field","page":"Scatttering","title":"Mean Field","text":"","category":"section"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :near_field|:far_field","category":"page"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"mathbfE_mf = mathbfE_sc","category":"page"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"","category":"page"},{"location":"scattering/#Intensity","page":"Scatttering","title":"Intensity","text":"","category":"section"},{"location":"scattering/#Scalar-2","page":"Scatttering","title":"Scalar","text":"","category":"section"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :near_field|:far_field","category":"page"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"I_sc(vecRt) = mathbfE_sc^2","category":"page"},{"location":"scattering/#Vectorial-2","page":"Scatttering","title":"Vectorial","text":"","category":"section"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :near_field|:far_field","category":"page"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"I_vec(hatnt) = mathbfE_vec^2 = sum_muE^mu_vec^2","category":"page"},{"location":"scattering/#Mean-Field-2","page":"Scatttering","title":"Mean Field","text":"","category":"section"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :near_field","category":"page"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"I_mf(mathbfRt) = I_sc(mathbfR t)\n+fracGamma^2(2k_0)^2 left   sum_j frac- beta_j^2    + frac1+langle sigma_j^z rangle 2R-r_j^2 right ","category":"page"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"regime = :far_field","category":"page"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"I_mf(mathbfRt) = I_sc(mathbfR t) + fracGamma^2(2k_0R)^2sum_j=1^N left ( -beta_j^2 + frac1 + langle sigma_j^z rangle 2right )","category":"page"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"","category":"page"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"scattered_electric_field","category":"page"},{"location":"scattering/#CoupledDipoles.scattered_electric_field","page":"Scatttering","title":"CoupledDipoles.scattered_electric_field","text":"scattered_electric_field(problem, atomic_states, sensors; regime=:near_field, use_sequencial=false)\n\nReturns a Matrix{ComplexF64} with value of the Eletric Laser + Electric Scattered from atoms\n\nproblem: LinearOptics or NonLinearOptics\natomic_states: A vector for Scalar, MeanField and PairCorrelation. A matrix Vectorial Model\nsensors: matrix with measurement points\nuse_sequencial turn on/off the internal parallelism\n\nNote:\n\nScalar (and other models) problem returns a Matrix and NOT a Vector, to maintain consistency   with Vectorial problem that necessary returns a Matrix,   where each column has the [Ex, Ey, Ez] components of the field.\nAlso, even for single sensor, returns a Matrix of one element.\n\nExample\n\nusing CoupledDipoles, Random\nRandom.seed!(111)\nN = 5\nkR, kh = 1.0, 1.0\natoms = Atom(Cylinder(), N, kR, kh)\n\ns, Δ = 1e-5, 1.0\nlaser = Laser(PlaneWave3D(), s, Δ; polarization=[1,0,0])\n\nproblem_scalar = LinearOptics(Scalar(), atoms, laser)\nproblem_vectorial = LinearOptics(Vectorial(), atoms, laser)\n\natomic_states_scalar = steady_state(problem_scalar)\natomic_states_vectorial = steady_state(problem_vectorial)\n\n## 1 sensor\nRandom.seed!(222)\nnSensors = 1\nsensor = Matrix(rand(3, nSensors)) # '3' == sensor lives in a 3D space\nscattered_electric_field(problem_scalar, atomic_states_scalar, sensor)\nscattered_electric_field(problem_vectorial, atomic_states_vectorial, sensor)\n\n\n## 10 sensors\nRandom.seed!(333)\nnSensors = 10\nsensor = rand(3, nSensors) # '3' == sensor lives in a 3D space\nscattered_electric_field(problem_scalar, atomic_states_scalar, sensor)\nscattered_electric_field(problem_vectorial, atomic_states_vectorial, sensor)\n\n\n\n\n\n","category":"function"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"laser_and_scattered_intensity","category":"page"},{"location":"scattering/#CoupledDipoles.laser_and_scattered_intensity","page":"Scatttering","title":"CoupledDipoles.laser_and_scattered_intensity","text":"laser_and_scattered_intensity(problem, atomic_states, sensor_positions; regime=:near_field)\n\nReturns a Vector{Float64} with value of the |Electric Laser + Electric Scattered|^2 from atoms\n\nproblem: LinearOptics or NonLinearOptics\natomic_states: β for Scalar/Vectorial Model, or [β,z] for Mean Field Model\nsensors: matrix with measurement points\n\n\n\n\n\n","category":"function"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"scattered_intensity","category":"page"},{"location":"scattering/#CoupledDipoles.scattered_intensity","page":"Scatttering","title":"CoupledDipoles.scattered_intensity","text":"scattered_intensity(problem, atomic_states, sensor_positions; regime=:near_field, use_sequencial=false)\n\nReturns a Vector{Float64} with value of the |Electric Scattered|^2 from atoms\n\nproblem: LinearOptics or NonLinearOptics\natomic_states: β for Scalar/Vectorial Model, or [β,z] for Mean Field Model\nsensor_positions: matrix with measurement points\nuse_sequencial turn on/off the internal parallelism\n\nExample\n\nusing CoupledDipoles, Random\nRandom.seed!(111)\nN = 5\nkR, kh = 1.0, 1.0\natoms = Atom(Cylinder(), N, kR, kh)\n\ns, Δ = 1e-5, 1.0\nlaser = Laser(PlaneWave3D(), s, Δ; polarization=[1,0,0])\n\nproblem_scalar = LinearOptics(Scalar(), atoms, laser)\nproblem_vectorial = LinearOptics(Vectorial(), atoms, laser)\n\natomic_states_scalar = steady_state(problem_scalar)\natomic_states_vectorial = steady_state(problem_vectorial)\n\n## 1 sensor\nRandom.seed!(222)\nnSensors = 1\nsensor = Matrix(rand(3, nSensors)) # '3' == sensor in position in 3D space\nscattered_intensity(problem_scalar, atomic_states_scalar, sensor)\nscattered_intensity(problem_vectorial, atomic_states_vectorial, sensor)\n\n\n## 10 sensors\nRandom.seed!(333)\nnSensors = 10\nsensor = rand(3, nSensors) # '3' == sensor in position in 3D space\nscattered_intensity(problem_scalar, atomic_states_scalar, sensor)\nscattered_intensity(problem_vectorial, atomic_states_vectorial, sensor)\n\n\n\n\n\n","category":"function"},{"location":"scattering/","page":"Scatttering","title":"Scatttering","text":"get_intensity_over_an_angle","category":"page"},{"location":"scattering/#CoupledDipoles.get_intensity_over_an_angle","page":"Scatttering","title":"CoupledDipoles.get_intensity_over_an_angle","text":"get_intensity_over_an_angle(problem::LinearOptics{Scalar}, atoms_states::Vector{ComplexF64}, θ::Number; tol=exp10(-7.4))\n\nUsed for the single angle and single single state (most probably user case).\n\nExample:\n\nusing CoupledDipoles, Random\nRandom.seed!(111)\nN = 5\nkR, kh = 1.0, 1.0\natoms = Atom(Cylinder(), N, kR, kh)\n\ns, Δ = 1e-5, 1.0\nlaser = Laser(PlaneWave3D(), s, Δ; polarization=[1,0,0])\n\nproblem_scalar = LinearOptics(Scalar(), atoms, laser)\natomic_states_scalar = steady_state(problem_scalar)\n\nθ = deg2rad(48)\nget_intensity_over_an_angle(problem_scalar, atomic_states_scalar, θ)\n\n\n\n\n\nget_intensity_over_an_angle(problem::LinearOptics{Scalar}, atoms_states::Vector{Vector{ComplexF64}}, θ::Number; tol=exp10(-7.4), exact_solution=false)\n\nUsed for the single angle and different states (for example, the output of time_evolution).\n\nExample:\n\nusing CoupledDipoles, Random\nRandom.seed!(111)\nN = 5\nkR, kh = 1.0, 1.0\natoms = Atom(Cylinder(), N, kR, kh)\n\ns, Δ = 1e-5, 1.0\nlaser = Laser(PlaneWave3D(), s, Δ; polarization=[1,0,0])\n\nproblem_scalar = LinearOptics(Scalar(), atoms, laser)\nu0 = default_initial_condition(problem_scalar)\ntspan = (0.0, 10.0)\nsolutions = time_evolution(problem_scalar, u0, tspan)\nstates = solutions.u\n\nθ = deg2rad(48)\nget_intensity_over_an_angle(problem_scalar, states, θ)\n\n\n\n\n\n","category":"function"},{"location":"variances_angles/rayleigh_variance/#Deviations-from-Rayleigh's-law","page":"Intensity Statistics","title":"Deviations from Rayleigh's law","text":"","category":"section"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"Our goal is to reproduce Figure 2 from the paper Cottier et all, 2019, where the authors studied the statistics of the scattered light, and found that the variance of the intensity distribution deviates from the expected Rayleigh's law.","category":"page"},{"location":"variances_angles/rayleigh_variance/#Step-1-Use-distributed-resources","page":"Intensity Statistics","title":"Step 1 - Use distributed resources","text":"","category":"section"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"This step is optional, but if you have a lot of memory of cpu cores, is a good ideia to use it. Since this is optional, if you don't have a cluster to test, just comment the lines related to addprocs","category":"page"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"using CairoMakie, LinearAlgebra\nusing Statistics: mean, var\nusing StatsBase: fit, normalize, Histogram\n\naddprocs(2; \n    exeflags=`--project=$(Base.active_project()) --threads 4`, \n    topology=:master_worker, \n    enable_threaded_blas=true\n)\n\n@everywhere begin\n    using CoupledDipoles, Random, Dagger\n\n    function produce_intensities(rep, N, L, w₀, s, Δ, sensors)\n        Random.seed!(1134 + rep)\n    \n        atoms = Atom(Cube(), N, L)\n        laser = Laser(Gaussian3D(w₀), s, Δ)\n        simulation = LinearOptics(Scalar(), atoms, laser)\n    \n        βₙ = steady_state(simulation)\n        intensities = scattered_intensity(simulation, βₙ, sensors; regime = :far_field)\n        return intensities\n    end\nend\n","category":"page"},{"location":"variances_angles/rayleigh_variance/#Step-2-Setup-Parameters","page":"Intensity Statistics","title":"Step 2 - Setup Parameters","text":"","category":"section"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"We use the exact configuration parameters from the paper. You will notice may Warning messages. This happen because a small laser waist leads to unreasonable results.","category":"page"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"If you are studying Cottier's paper, note that the results from the paper are not accurate due to its small laser waist, even though they general paper's message is still correct.","category":"page"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"### ------------ ATOMS SPECS ---------------------\nL = 32.4\nN = [684, 6066]\n\n\n### ------------ LASER SPECS ---------------------\nΔ = 1.0\ns = 1e-6\nw₀ = L / 4\n\n### ------------ SIMULATION SPECS ---------------------\nsensors = get_sensors_ring(; num_pts = 720, kR = 300, θ = 5π / 12)\nmaxRep = 15","category":"page"},{"location":"variances_angles/rayleigh_variance/#Step-3-Produce-Intensities","page":"Intensity Statistics","title":"Step 3 - Produce Intensities","text":"","category":"section"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"For each atom number N, create maxRep atomic configurations, compute their state states, and scattered light intensity. The normalization over the mean comes from the paper.","category":"page"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"all_intensities = map(N) do N\n    _intensities = map(1:maxRep) do rep\n        Dagger.@spawn produce_intensities(rep, N, L, w₀, s, Δ, sensors)\n    end\n\n    many_intensities = fetch.(_intensities)\n    many_intensities = reduce(vcat, many_intensities)\n    all_intensities_over_mean = many_intensities ./ mean(many_intensities)\n\n    all_intensities_over_mean\nend;\n","category":"page"},{"location":"variances_angles/rayleigh_variance/#Step-4-Histograms","page":"Intensity Statistics","title":"Step 4 -  Histograms","text":"","category":"section"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"Instead of ploting histogram for each particle number, we are interested in the data from the histogram to display it in a scatter plot. Also, this is the moment to compute the variance of all intensities.","category":"page"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"bins = 10.0 .^ range(log10(1e-6), log10(75); length = 30)\n\nxy_data = map(eachindex(N)) do n\n    h = fit(Histogram, all_intensities[n], bins)\n\n    h_norm = normalize(h; mode = :pdf)\n    bins_edges = collect(h_norm.edges[1])\n    bins_centers = [sqrt(bins_edges[i] * bins_edges[i+1]) for i = 1:(length(bins_edges)-1)]\n    variance = var(all_intensities[n])\n\n    # x_data_histogram, y_data_histogram, variance\n    (bins_centers, h_norm.weights, variance)\nend","category":"page"},{"location":"variances_angles/rayleigh_variance/#Step-5-Plot","page":"Intensity Statistics","title":"Step 5 - Plot","text":"","category":"section"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"Overlay the Distribution Probability in a single figure.","category":"page"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"The begin-end structure is just to facilitate the Figure development for the user. It is easier to just run the block at once at every little plot tweak, than select and run everything all the time.","category":"page"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"begin\n    fig = Figure(size = (800, 450))\n    ax = Axis(\n        fig[1, 1],\n        xlabel = \"Intensity\",\n        ylabel = \"Probability Distribution\",\n        title = \"\",\n        xlabelsize = 25,\n        ylabelsize = 25,\n        xticklabelsize = 20,\n        yticklabelsize = 20,\n        xscale = log10,\n        yscale = log10,\n    )\n\n    ## theoretical curve\n    x_ray = range(0.01, 50; step = 0.15)\n    y_ray = exp.(-x_ray)\n    lines!(ax, x_ray, y_ray, linestyle = :dash, label = \"Rayleigh\", color = :black, linewidth = 4)\n\n    for n = 1:2\n        x = xy_data[n][1]\n        y = xy_data[n][2]\n        v = xy_data[n][3] # variance\n        notNull = findall(y .> 0)\n        scatter!(\n            ax,\n            x[notNull],\n            y[notNull];\n            label = \"N=$(N[n]), Variance = $( round(v,digits=3 ))\",\n            marker = :circle,\n            markersize = 20,\n        )\n    end\n    ylims!(1e-6, 10)\n    xlims!(1e-1, 100)\n    axislegend(position = :rt, labelsize = 20)\n    CairoMakie.save(\"rayleigh_deviation.png\", fig)\n    fig\nend","category":"page"},{"location":"variances_angles/rayleigh_variance/","page":"Intensity Statistics","title":"Intensity Statistics","text":"(Image: Rayleigh Deviation)","category":"page"},{"location":"lasers/lasers/#Lasers","page":"Laser","title":"Lasers","text":"","category":"section"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"To drive interaction of the atomic cloud, one usually pump a Plane Wave of Gaussian Beam, therefore, you have the PlaneWave and Gaussian abstract types. In practive, as user, you will be dealing with their subtypes, the PlaneWave3D or Gaussian3D, but the most important object will be the Laser.","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"First an example with PlaneWave3D","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"s, Δ = 1e-5, 1.0 # good values\nlaser_plane = Laser(PlaneWave3D(), s, Δ)","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"For Gaussian3D you have to provide the beam waist","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"waist = 0.75*kL # there is no perfect value here\nlaser_gaussian = Laser(Gaussian3D(waist), s, Δ)","category":"page"},{"location":"lasers/lasers/#turn_off!","page":"Laser","title":"turn_off!","text":"","category":"section"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"If you need to turn off the pump, the function turn_off!(laser) does exactly what it imply, but you cannot turn on later - If you need the laser back, you have to make a copy of the original.","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"waist = 0.75*kL # there is no perfect value here\nlaser_gaussian = Laser(Gaussian3D(waist), s, Δ)\n\nturn_off!(laser_gaussian)","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"Here a complete example of switch on-off dynamics","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"using CoupledDipoles, Random\n\n# atom's settings\nN, ρk⁻³ = 500, 0.02\nN, kR = cube_inputs(N, ρk⁻³)\nRandom.seed!(1111)\natoms = Atom(CoupledDipoles.Sphere(), N, kR)\n\n# laser's settings\ns, Δ = 1e-5, -2.0\nlaser = Laser(Gaussian3D(kR / 2), s, Δ)\n\n# create different models\nscalar = LinearOptics(Scalar(), atoms, laser)\nss_scalar = steady_state(scalar) # use the laser to get the state state\n\n# swtich-off dynamics\ntspan = (0, 75.0) # interval extremas\nsaveat = range(tspan[1], tspan[2], length=100) # force states to saved on these times\n\nturn_laser_off!(scalar) # have a time evolution without a pump\nstates_off = time_evolution(scalar, ss_scalar, tspan; saveat=saveat)\n\n# get some property to vizualize\ndecay_power = map(states_off.u) do states\n    scattered_power(scalar, states)\nend\n\n# using CairoMakie\n# fig = Figure()\n# ax = Axis(fig[1,1], xlabel=\"time\", ylabel=\"power\", yscale=log10)\n# scatterlines!(ax, saveat, decay_power)\n# fig","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"(Image: Decay After Laser is Turn Off)","category":"page"},{"location":"lasers/lasers/#Cool-Image","page":"Laser","title":"Cool Image","text":"","category":"section"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"You can actually see the spatial profile of your laser with a volume slice","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":" using GLMakie, CoupledDipoles, LinearAlgebra\n\n## FIGURE COLORS\nmyBG = RGBf(6/255, 0, 26/255 )\nmyGridColor = RGBf(30/255, 0/255, 30/255 )\nsensor_color = RGBf(247/255, 94/255, 133/255)\nmyColor =  cgrad(  [RGBf(0, 81/255, 123/255 ),\n                    RGBf(0, 221/255, 236/255),\n                    RGBf(201/255,251/255,255/255)])\n\nmyColor =  cgrad(  [RGBf(4/255, 0, 21/255 ),\n                    RGBf(0, 81/255, 123/255 ),\n                    RGBf(0, 221/255, 236/255),\n                    RGBf(201/255,251/255,255/255)])\nfig = Figure( backgroundcolor=myBG, size=(800, 800),)\nax = Axis3(fig[1, 1], aspect = (1,1,1),)\n\nw₀, s, Δ = 1π, 1e-5, 0.5\nlaser = Laser(Gaussian3D(w₀), s, Δ)\n\nx = LinRange(-10, 10, 50)\ny = LinRange(-10, 10, 50)\nz = LinRange(-10, 10, 50)\n\nvol = [norm(laser_field(laser, [X, Y, Z])) for X ∈ x, Y ∈ y, Z ∈ z]\nplt = volumeslices!(ax, x, y, z, vol, colormap=myColor)\nplt[:update_yz][](25)\nplt[:update_xz][](50)\n\n\nfig\n","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"(Image: Decay After Laser is Turn Off)","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"PlaneWave3D","category":"page"},{"location":"lasers/lasers/#CoupledDipoles.PlaneWave3D","page":"Laser","title":"CoupledDipoles.PlaneWave3D","text":"PlaneWave3D()\n\n\n\n\n\n","category":"type"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"Gaussian3D","category":"page"},{"location":"lasers/lasers/#CoupledDipoles.Gaussian3D","page":"Laser","title":"CoupledDipoles.Gaussian3D","text":"Gaussian3D(w₀)\n\nw₀ is the Beam Waist.\n\nPlease, avoid w₀ < 2λ (λ = 2π / k₀) \n\n\n\n\n\n","category":"type"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"For convenience, ","category":"page"},{"location":"lasers/lasers/","page":"Laser","title":"Laser","text":"Laser","category":"page"},{"location":"lasers/lasers/#CoupledDipoles.Laser","page":"Laser","title":"CoupledDipoles.Laser","text":"Laser(pump, s, Δ, direction, polarization)\n\npump is e.g PlanweWave3D or Gaussian3D\ns: saturation on ressonance (used for raby_frequency = Γ √(s / 2))\nΔ: the detunning (laser - atomic frequency) \ndirection: Array is the propagation direction (default is [0,0,1])\npolarization: Array is the polarization direction (default is [0,0,0])\n\nNote that direction and polarization have to be orthogonal.\n\n\n\n\n\n","category":"type"},{"location":"create_atoms/atoms/#Creating-Atoms","page":"Atom","title":"Creating Atoms","text":"","category":"section"},{"location":"create_atoms/atoms/#Default-distributions","page":"Atom","title":"Default distributions","text":"","category":"section"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"Currently, the package only supports 3D objects, namely Sphere, Cube, and Cylinder. However, the source code allows to extend functionalities to 1D and 2D in future developments - please, collaborate with a pull request. ","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"To create atoms, use the Atom constructor, the base syntax is the following","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"using CoupledDipoles, Random\nRandom.seed!(2354)\nnAtoms = 5000\n\n# `CoupledDipoles` and `CairoMakie` expoerts 'Sphere()', \n# therefore I had to be specific and write `CoupledDipoles.Sphere()`\nsphere_radius = 1.5\nsphere_cloud = Atom(CoupledDipoles.Sphere(), nAtoms, sphere_radius)\n\ncube_side = 1.0\ncube_cloud = Atom(Cube(), nAtoms, cube_side)\n\ncylinder_radius = 0.5\ncylinder_height = 2.0\ncylinder_cloud = Atom(Cylinder(), nAtoms, cylinder_radius, cylinder_height)","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"You just created a matrix with the atoms. The atoms positions are in Cartesian Coordinates, and stored in column-major (each column correspond to an atom).","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"To see your atoms you need have to plot them with some external package","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"using CairoMakie\nfig = Figure(size = (800, 300))\nax_sphere = Axis3(fig[1:2, 1:2], aspect = (1, 1, 1))\nax_cube = Axis3(fig[1:2, 3:4], aspect = (1, 1, 1))\nax_cylinder = Axis3(fig[1:2, 5:6], aspect = (1, 1, 1))\n\nsx, sy, sz = sphere_cloud.r[1, :], sphere_cloud.r[2, :], sphere_cloud.r[3, :]\nscatter!(ax_sphere, sx, sy, sz, color = sz)\n\ncx, cy, cz = cube_cloud.r[1, :], cube_cloud.r[2, :], cube_cloud.r[3, :]\nscatter!(ax_cube, cx, cy, cz, color = cz)\n\ncyx, cyy, cyz = cylinder_cloud.r[1, :], cylinder_cloud.r[2, :], cylinder_cloud.r[3, :]\nscatter!(ax_cylinder, cyx, cyy, cyz, color = cyz)\n\nhidedecorations!(ax_sphere)\nhidedecorations!(ax_cube)\nhidedecorations!(ax_cylinder)\nfig\n\nsave(\"geometries.png\", fig)","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"(Image: 3D examples)","category":"page"},{"location":"create_atoms/atoms/#User-defined-geometry","page":"Atom","title":"User defined geometry","text":"","category":"section"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"The Atom constructor holds the shape used for multiple-dispatch on the right physical equation, r is the matrix containg the atomic positions, N is the number of atom, and sizes is a generic radius for the system.","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"struct Atom{T<:Dimension}\n    shape::T\n    r::Matrix{Float64}\n    N::Int64\n    sizes::Any\nend","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"If a user wants to create their own atomic configuration, there are two constraints to consider:","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"The shape field can be handled easily by choosing one of the available options: Sphere, Cube, or Cylinder.\nThe matrix containing the atom positions must have each Cartesian dimension represented by a row.","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"Here's an example code snippet demonstrating the creation of a custom atomic configuration:","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"# Define atom positions as separate arrays\natom_1 = [1, 1, 1]\natom_2 = [2, 2, 2]\natom_3 = [3, 3, 3]\natom_4 = [4, 4, 4]\n\n# Combine atom positions into a single matrix\nr = transpose(vcat(atom_1, atom_2, atom_3, atom_4))\n# Note: The `transpose` function is used to fulfill the matrix constraint.\n\n# Convert the transposed result to an actual matrix using `Array`\nr = Array(r)\n# Note: The `transpose` operation returns a non-matrix object, so we use `Array` to materialize it.\n\n# Create the `Atom` object with the chosen shape and custom positions\ndummy_dimension = 5\natoms = Atom(Cube(), r, dummy_dimension)","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"The usage of transpose, followed by Array, is necessary to adhere to the package internals expectations.","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"Another example on how to concatenate vectors.","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"# (...)\nnAtoms = 5000\nx = 0.5randn(nAtoms)\ny = 0.5randn(nAtoms)\nz = 2rand(nAtoms)\nr  = hcat(x,y,z) |> transpose |> Array\n\n\ndummy_radius = 0.5\ndummy_height = 2.0\natoms = Atom(Cylinder(), r, dummy_radius, dummy_height)\n\nfig = Figure(size = (450, 450))\nax_sphere = Axis3(fig[1, 1])\nsx, sy, sz = atoms.r[1, :], atoms.r[2, :], atoms.r[3, :]\nscatter!(ax_sphere, sx, sy, sz, color = sz)    \nhidedecorations!(ax_sphere)\nfig","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"(Image: Gaussian Cylinder)","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"","category":"page"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"Sphere","category":"page"},{"location":"create_atoms/atoms/#CoupledDipoles.Sphere","page":"Atom","title":"CoupledDipoles.Sphere","text":"    Sphere(; gaussian=false)\n\nIf gaussian=true, produces a Gaussian Sphere with μ = 0 (mean = 0) and variance = kR (σ^2 = kR)\n\n\n\n\n\n","category":"type"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"Cube","category":"page"},{"location":"create_atoms/atoms/#CoupledDipoles.Cube","page":"Atom","title":"CoupledDipoles.Cube","text":"    Cube()\n\n\n\n\n\n","category":"type"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"Cylinder","category":"page"},{"location":"create_atoms/atoms/#CoupledDipoles.Cylinder","page":"Atom","title":"CoupledDipoles.Cylinder","text":"    Cylinder()\n\n\n\n\n\n","category":"type"},{"location":"create_atoms/atoms/","page":"Atom","title":"Atom","text":"Atom","category":"page"},{"location":"create_atoms/atoms/#CoupledDipoles.Atom","page":"Atom","title":"CoupledDipoles.Atom","text":"Atom(geometry::Cube, N::Int64, kL::Union{Real,Integer}; r_min)\n\nArguments\n\ngeometry::Cube: The geometry of the atom object, which should be a Cube.\nN::Int64: The number of atoms.\nkL::Union{Real,Integer}: Cube's side length.\n\nKeyword Arguments\n\n:r_min: Optional keyword argument specifying the minimum distance between atoms.\n\nBy default it is computed with the radius_of_exclusion() method\n\nExample\n\natom = Atom(Cube(), 100, 5.0; r_min = 0.1)\n\n\n\n\n\nAtom(geometry::Cylinder, N::Int64, R::Union{Real,Integer}, h::Union{Real,Integer}; r_min)\n\nArguments\n\ngeometry::Cylinder: The geometry of the atom object, which should be a Cylinder.\nN::Int64: The number of atoms.\nR::Union{Real,Integer}: The radius of the cylinder.\nh::Union{Real,Integer}: The height of the cylinder.\n\nKeyword Arguments\n\n:r_min: Optional keyword argument specifying the minimum distance between atoms.\n\nBy default it is computed with the radius_of_exclusion() method\n\nExample\n\natom = Atom(Cylinder(), 100, 5.0, 10.0; r_min = 0.1)\n\n\n\n\n\nAtom(geometry::Sphere, N::Int64, kR::Union{Real,Integer}; kwargs...)\n\nArguments\n\ngeometry::Sphere: The geometry of the atom object, which should be a Sphere.\nfor Gaussian distribution, set gaussian=true\nN::Int64: The number of atoms.\nkR::Union{Real,Integer}: The radius for the sphere.\n\nKeyword Arguments\n\n:r_min: Optional keyword argument specifying the minimum distance between atoms. \n\nBy default it is computed with the radius_of_exclusion() method\n\nExample\n\natom_homogenous = Atom(Sphere(), 100, 5.0; r_min = 0.1)\natom_gaussian = Atom(Sphere(gaussian=true), 100, 5.0; r_min = 0.1)\n\n\n\n\n\n","category":"type"},{"location":"#CoupledDipoles.jl","page":"Home","title":"CoupledDipoles.jl","text":"","category":"section"},{"location":"#**Installation**","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is package is not registred in julia, you have to use its github URL","category":"page"},{"location":"","page":"Home","title":"Home","text":"Due to its many dependencies, the installation process may take around 10 minutes and requires at least 16Gb of RAM on your device","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\n# Pkg.add(\"MKL\") # (if installation goes wrong, run this line, and try to install again)\nPkg.add(url=\"https://github.com/NoelAraujo/CoupledDipoles.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To verify that everything is working correctly, run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CoupledDipoles\n# Pkg.test(\"CoupledDipoles\")","category":"page"},{"location":"#First-Example","page":"Home","title":"First Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's create a problem with N=1000 atoms inside a Cube of size kR=40, pumped by a laser with saturation s=1e-6 and on resonance Δ=0. We'll use the Atom and Laser constructors to define the problem, and then create a Scalar Model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"From the problem you get, for example, the steady_state","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CoupledDipoles\nN, kR = 1000, 40\natoms = Atom(Cube(), N, kR)\n\ns, Δ = 1e-6, 0.0\nlaser = Laser(PlaneWave3D(), s, Δ)\nproblem = LinearOptics(Scalar(), atoms, laser)\nβₛₛ = steady_state(problem)","category":"page"},{"location":"#Cool-image","page":"Home","title":"Cool image","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check an atomic cloud pumped by a laser, and surrounded by a ring of sensors, where some scattered property can be measured.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Figure 1 of the thesis)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is the code","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GLMakie, CoupledDipoles, LinearAlgebra, Random\n\n## FIGURE COLORS\nmyBG = RGBf(6/255, 0, 26/255 )\nmyGridColor = RGBf(30/255, 0/255, 30/255 )\nsensor_color = RGBf(247/255, 94/255, 133/255)\nmyColor =  cgrad(  [\n    RGBf(0, 81/255, 123/255 ),\n    RGBf(0, 221/255, 236/255),\n    RGBf(201/255,251/255,255/255)\n    ]\n)\n\n## DATA\nRandom.seed!(3456)\natoms = Atom(CoupledDipoles.Sphere(), 6000, 10)\nx_a, y_a, z_a = atoms.r[1, :], atoms.r[2, :], atoms.r[3, :]\n\nfig = let\n    myColor =  cgrad(  [RGBf(4/255, 0, 21/255 ),\n                        RGBf(0, 81/255, 123/255 ),\n                        RGBf(0, 221/255, 236/255),\n                        RGBf(201/255,251/255,255/255) ])\n    fig = Figure(; size=(1200, 1000), backgroundcolor=myBG, fontsize=25)\n    ax = Axis3(\n        fig[1, 1];\n        xlabel=\"X\",\n        ylabel=\"Y\",\n        zlabel=\"Z\",\n\n        zgridcolor=myGridColor,\n        xgridcolor=myGridColor,\n        ygridcolor=myGridColor,\n\n        ztickcolor=:white,\n        xtickcolor=:white,\n        ytickcolor=:white,\n\n        xlabelcolor=:white,\n        ylabelcolor=:white,\n        zlabelcolor=:white,\n        titlecolor=:white,\n\n        xgridwidth = 1,\n        ygridwidth = 1,\n        zgridwidth = 1,\n\n        backgroundcolor=myBG,\n        aspect = (1,1,1),\n\n        xticksvisible = false,\n        yticksvisible = false,\n        zticksvisible = false,\n\n        xticklabelsvisible = false,\n        yticklabelsvisible = false,\n        zticklabelsvisible = false,\n    )\n\n\n    w₀, s, Δ = 3π, 1e-5, 0.5\n    laser = Laser(Gaussian3D(w₀), s, Δ)\n\n    x = LinRange(-15, 15, 100)\n    y = LinRange(-15, 15, 100)\n    z = LinRange(-15, 15, 100)\n\n    vol = [norm(laser_field(laser, [X, Y, Z])) for X ∈ x, Y ∈ y, Z ∈ z]\n    plt = volumeslices!(ax, x, y, z, vol, colormap=myColor)\n    idx_slice = 40\n    plt[:update_yz][](99)\n    plt[:update_xz][](99)\n    plt[:update_xy][](1)\n    ## ATOMOS\n    validIdx = 1:6000\n    scatter!(ax, x_a[validIdx], y_a[validIdx], z_a[validIdx],\n        strokewidth=0.5, strokecolor=myGridColor,\n        color=z_a[validIdx], colormap=myColor, markersize=20)\n\n\n\n    ## LASER SHAPE\n    a = w₀/2  # Scaling factor along x-axis\n    b = w₀/2  # Scaling factor along y-axis\n    c = 12.0  # Scaling factor along z-axis\n\n    # Define the parametric equations for the 'hyperboloid'\n    u = LinRange(-1, 1, 50)\n    v = LinRange(0, 2 * pi, 50)\n    X = [a*cosh(u)*cos(v) for u in u, v in v]\n    Y = [b*cosh(u)*sin(v) for u in u, v in v]\n    Z = [c*sinh(u) for u in u, v in v]\n\n    surface!(ax, X, Y, Z; shading = Makie.automatic, \n        backlight = 1.0f0, color = sqrt.(X .^ 2 .+ Y .^ 2 .+ Z .^ 2),\n        colormap = myColor, transparency = false,\n        )\n    wireframe!(ax, X, Y, Z; linewidth = 0.5, transparency = true)\n\n\n    # SENSORES\n    sensors = get_sensors_ring(; num_pts = 64, kR = 15, θ = 5π / 12)\n    sx, sy, sz = sensors[1,:], sensors[2,:], sensors[3,:]\n    scatter!(ax, sx, sy,sz,color=sensor_color, markersize=20)\n\n\n    xlims!(ax, -15,15)\n    ylims!(ax, -15,15)\n    zlims!(ax, -15,15)\n    fig\nend","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"dipole_example/single_atom_volume/#Single-Atom","page":"Single Atom","title":"Single Atom","text":"","category":"section"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"The special case of a single atom is the radiation pattern of a dipole, defined in electromagnetism books.","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"To create a single atom system, set N=1. Note that all functions will output a Matrix of 1 element. This was an intentional decision to make internal functions interoperate effectively - if all inputs were a matrix, there was no ambiguity about the number of particles.","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"We need to use the Vectorial model to best visualize the radiation pattern. The code below is a minimal working example for checking the radiation pattern through a volume slice. The laser will be pointing in the negative x-direction, to make the visualization clearer.","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"using CoupledDipoles, Random\n\n# cloud settings\nN = 1\nkR = 10\n\n# laser settings\nw₀ = 4π\ns = 1e-5\nΔ = 0.0\n\nRandom.seed!(2044)\nsingle_atom =Atom(CoupledDipoles.Cylinder(), N, kR, kR)\nlaser = Laser(Gaussian3D(w₀), s, Δ; direction=[-1,0,0], polarization=[0,0,1])\nproblem = LinearOptics(Vectorial(), single_atom, laser)\nβₙ = steady_state(problem)","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"We had to apply :near_field regime manually to compute the intensity, because the default regime is :far_field. To evaulate the intensity in a certain spatial domain, we  use a list comprehension.","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"x = LinRange(-100, 100, 100)\ny = LinRange(-100, 100, 100)\nz = LinRange(-100, 100, 100)\n\n## this plot only works for near field regime\n_vol = [laser_and_scattered_intensity(problem, βₙ, Matrix([X Y Z]');regime=:near_field)[1] for X ∈ x, Y ∈ y, Z ∈ z]\nlaserOn = log10.(_vol)\n\n_vol = [scattered_intensity(problem, βₙ, Matrix([X Y Z]');regime=:near_field)[1] for X ∈ x, Y ∈ y, Z ∈ z]\nlaserOff = log10.(_vol)","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"In the following, the figures represents the radiation in space for single atom and the color range was choosen ad hoc to higlight the expected dipole radiation pattern.","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"using ColorSchemes\nusing GLMakie\n\n\nfig = Figure(resolution = (800, 600))\nax_on = Axis3(fig[1, 1], title = \"Dipole Radiation\", aspect=:data)\n\non_plt = volumeslices!(ax_on, x, y, z, laserOff,\n    colormap=cgrad( ColorSchemes.linear_kryw_0_100_c71_n256, rev=false),\n    colorrange=(-10, -7.5)\n    )\non_plt[:update_yz][](100)\non_plt[:update_xz][](50)\non_plt[:update_xy][](1)\n\nfig\n","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"(Image: Dipole Radiation)","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"Now a comparison between with laser on and off","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"fig = Figure(size = (900, 800), background_color=:transparent)\n    ax_on = Axis3(fig[1, 1], title = \"Laser On\", aspect=:data)\n    ax_off = Axis3(fig[1, 2], title = \"Laser Off\", aspect=:data)\n\n    on_plt = volumeslices!(ax_on, x, y, z, laserOn,\n        colormap=cgrad( ColorSchemes.linear_kryw_0_100_c71_n256, rev=false),\n        colorrange=(-10, -7.5)\n        )\n    on_plt[:update_yz][](100)\n    on_plt[:update_xz][](50)\n    on_plt[:update_xy][](1)\n\n    off_plt = volumeslices!(ax_off, x, y, z, laserOff,\n        colormap=cgrad( ColorSchemes.linear_kryw_0_100_c71_n256, rev=false),\n        colorrange=(-10, -7.5)\n        )\n    off_plt[:update_yz][](100)\n    off_plt[:update_xz][](50)\n    off_plt[:update_xy][](1)\n\n    cbar = Colorbar(fig, off_plt; label=\"log10( Intensity )\", flipaxis=false,  vertical = false, width = Relative(4/5),ticks=WilkinsonTicks(3))\n    fig[2, :] = cbar\n\n    # save(\"on_off_radiation.png\", fig)\n    fig","category":"page"},{"location":"dipole_example/single_atom_volume/","page":"Single Atom","title":"Single Atom","text":"(Image: Laser On and Off)","category":"page"}]
}
